## BM62 斐波那契数列

动态规划的典型题，该题有三种解答方法：

方法1：递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389978-swEaca-image.png)

```java
public class Solution {
    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        return fib(N - 1) + fib(N - 2);
    }
}
```

方法2：递归+缓存/记忆化递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389988-dvJhAs-image.png)

```java
public class Solution {
    int[] memo = new int[41];//备忘录，这里的备忘录也可以写进Fibonacci方法
    public int Fibonacci(int n) {
        //利用状态数组memo保存斐波那契数列的每一项
        // memo[1] = 1;
        // memo[2] = 1;
        return f(n);
    }
    //实际计算斐波那契数列的方法
    public int f(int n) {
        if(n == 1 || n == 2) {
            return 1;
        }
        if(memo[n] == 0) {//这个条件很重要，只有备忘录里没有的才需要计算，已经有的直接返回即可
            memo[n] = f(n - 1) + f(n - 2);//尝试画图理解这个过程，凭空思考往往容易出错
        }
        return memo[n];
    }
}
```

方法3：动态规划

以上两种方法都是【自顶向下】，那么如何实现【自底向上】呢？所谓自底向上即先计算f(n-1)和f(n-2)，再计算f(n)。

如果状态数组命名为dp，表示我们采用【自底向上】递推的方式求解，这是一种习惯。

> 「记忆化递归」实际上也是一种遍历行为，因此也叫「记忆化搜索」。「记忆化递归」更符合人们思考问题的方式：直接面对问题寻找解决方案，并且记录每一步求解的结果，是一种「自顶向下」的思考模式。
>
> 「动态规划」采用了一种很不一样的方式，不直接面对问题求解，而是去发现这个问题最开始的样子，通过一步一步「递推」的方式，最终求得原问题的答案，是一种「自底向上」的思考模式。
>
> 在《算法导论》上，「自顶向下」递归求解与「自底向上」递推求解都称为「动态规划」，我们这个教程为了区分「自顶向下」与「自底向上」，把「自顶向下」递归求解的过程称为「记忆化递归」，而只把「自底向上」递推求解的过程称为「动态规划」。
>
> 作者：liweiwei1419
> 链接：https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/9vi9p7/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
public class Solution {
    public int Fibonacci(int n) {
        //创建状态数组
        int[] dp = new int[n+1];//状态数组
        //实例化状态数组前两个元素
        dp[0] = 0;
        dp[1] = 1;
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

当然还可以进一步优化，我们发现计算f(6)的时候只使用到了f(5)和f(4)，前面f(0)-f(3)都是没有必要保存的，所以只需要3个变量即可。

```java
public class Solution {
    public int Fibonacci(int n) {
        //变量--本质上保存状态
        int a = 0;//f(n - 1)
        int b = 1;//f(n - 2)
        int c = 0;//f(n)，保存f(n-1) + f(n - 2)
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            c = a + b;//递推公式f(n)=f(n-1)+f(n-2)
            a = b;//更新
            b = c;//更新
        }
        return c;//返回f(n)
    }
}
```

## BM63 跳台阶

本质上和BM62斐波那契数列一样。

```java
public class Solution {
    public int jumpFloor(int target) {
        if(target==1){
            return 1;
        }else if(target==2){
            return 2;
        }
        return jumpFloor(target-1)+jumpFloor(target-2);
    }
}
```



## BM64 最小花费爬楼梯

> **知识点：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **思路：**
>
> 题目同样考察斐波那契数列的动态规划实现，不同的是题目要求了最小的花费，因此我们将方案统计进行递推的时候只记录最小的开销方案即可。
>
> **具体做法：**
>
> - step 1：可以用一个数组记录每次爬到第i阶楼梯的最小花费，然后每增加一级台阶就转移一次状态，最终得到结果。
> - step 2：**（初始状态）** 因为可以直接从第0级或是第1级台阶开始，因此这两级的花费都直接为0.
> - step 3：**（状态转移）** 每次到一个台阶，只有两种情况，要么是它前一级台阶向上一步，要么是它前两级的台阶向上两步，因为在前面的台阶花费我们都得到了，因此每次更新最小值即可，转移方程为：dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/CD2B95CDF3D0BEA28A46D1C0172B9F61)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param cost int整型一维数组 
     * @return int整型
     */
    public int minCostClimbingStairs (int[] cost) {
        // write code here
        //状态数组--记录每次爬到第i级楼梯的最小花费
        int[] dp = new int[cost.length+1];
        //初始状态--因为可以直接从0或1级台阶开始，花费都是0
        dp[0] = 0;
        dp[1] = 0;
        //状态转移
        for(int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);//状态转移方程(难点)
        }
        return dp[cost.length];//爬到第i级楼梯的最小花费，即爬到cost数组最后一级楼梯的后一级楼梯的最小花费（理解这题的要求是越过cost数组中下标cost.length-1那级台阶，计算cost.length那级台阶）
    }
}
```

## BM65 最长公共子序列 *

这题是真的难，看了两个多小时，还是没有领会到精髓。

首先附上b站视频，讲的听清晰的：https://www.bilibili.com/video/BV14A411v7mP/

其次附上牛客官方讲解：--有些地方格式错误，懒得修改了，后面复习的时候修改吧。

> **知识点1：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **知识点2：栈**
>
> 栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
>
> **思路：**
>
> 能够递归解决的也可以用栈解决的，递归实现将问题缩小往前，然后将符合条件的字符依次拼接，栈也可以实现。
>
> **具体做法：**
>
> - step 1：优先检查特殊情况。
> - step 2：获取最长公共子序列的长度可以使用动态规划，我们以dp[i][j]dp[i][j]*d**p*[*i*][*j*]表示在s1中以ii*i*结尾，s2中以jj*j*结尾的字符串的最长公共子序列长度。
> - step 3：遍历两个字符串的所有位置，开始状态转移：若是ii*i*位与jj*j*位的字符相等，则该问题可以变成`1+dp[i−1][j−1]1+dp[i-1][j-1]1+*d**p*[*i*−1][*j*−1]`，即到此处为止最长公共子序列长度由前面的结果加1。
> - step 4：若是不相等，说明到此处为止的子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，因此我们考虑换成两个子问题，`dp[i][j−1]dp[i][j-1]*d**p*[*i*][*j*−1]或者dp[i−1][j]dp[i-1][j]*d**p*[*i*−1][*j*]`，我们取较大的一个就可以了。
> - step 5：得到最长长度后，获取不需要第二个辅助数组b，直接从dp数组最后一位开始，每次比较当前位置与其左、上、左上的关系，然后将符合要求的字符加入栈中，符合要求即来自dp表格左上方的字符。
> - step 6：最后将栈中的字符拼接即可得到最长公共子序列，注意检查子序列是否为空。

光看上面的讲解还是有点云里雾里的，附上图像，可以试着填一填，体会一下思路：

![image-20221010232331017](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221010232331017.png)

另外这是牛客网上的图：（说实话，动图往往不太适合理解，很多时候一张静态图片足矣）

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/C8A06E419BA9D0380E76B9F353AC0956)

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        //有空字符串，不会有子序列
        if(s1.length() == 0 || s2.length() == 0) {
            return "-1";
        }
        int len1 = s1.length();
        int len2 = s2.length();
        //状态变量：dp[i][j]表示字符串s1到第i位，字符串s2到第j位，两个子字符串的最长公共子序列的长度
        int[][] dp = new int[len1 + 1][len2 + 1];
        //遍历两个字符串，求每个位置的最长公共子序列长度--即遍历二维数组
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                //状态转移方程
                //两个字符相等
                if(s1.charAt(i-1) == s2.charAt(j-1)) {//charAt(index)中index是从0开始的
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //来自上方后者左边的最大值--理解一下为什么取最大值，因为求的是最大公共子序列的长度
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        // for(int i = 1; i <= len1; i++) {
        //     for(int j = 1; j <= len2; j++) {
        //         System.out.print(dp[i][j]+",");
        //     }
        // }
        //动态规划数组已经计算完毕
        //下面是求具体最长公共子序列
        int i = len1;
        int j = len2;
        Stack<Character> stack = new Stack<>();
        while(dp[i][j] != 0) {//退出条件
            if(dp[i][j] == dp[i-1][j]) {
                i--;
            }else if(dp[i][j]==dp[i][j-1]) {
                j--;
            }else if(dp[i][j] > dp[i-1][j-1]) {
                i--;
                j--;
                stack.push(s1.charAt(i));//当然这里也可以s2.charAt(j)
            }
        }
        String res = "";//空字符串
        while(!stack.isEmpty()) {
            res += stack.pop();
        }
        //如果没有公共子序列，需要返回-1，这里需要处理一下
        return res.isEmpty() ? "-1" : res;
    }
}
```

## BM66 最长公共子串 *

其实这题和BM65相似，比最长公共子序列更简单一些，因为公共子序列需要考虑字符的拼接问题，而子串只需要从原字符串截取即可。

同样附上B站讲解：https://www.bilibili.com/video/BV1aK411J7b8/

![image-20221011010100402](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221011010100402.png)

牛客官方解答：这题没有给出图像，有点遗憾，虽然和上面没什么区别就是了。

> 注意这题求的是最长公共子串，不是最长公共子序列，子序列可以是不连续的，但子串一定是连续的。
>
> 定义dp[i][j]表示字符串str1中第i个字符和str2种第j个字符为最后一个元素所构成的最长公共子串。如果要求dp[i][j]，也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串，我们首先需要判断这两个字符是否相等。
>
> - 如果不相等，那么他们就不能构成公共子串，也就是
>   **dp[i][j]=0;**
> - 如果相等，我们还需要计算前面相等字符的个数，其实就是dp[i-1][j-1]，所以
>   **dp[i][j]=dp[i-1][j-1]+1**;
>
> 有了递推公式，代码就比较简单了，我们使用两个变量，一个记录最长的公共子串，一个记录最长公共子串的结束位置，最后再对字符串进行截取即可.

```java
import java.util.*;


public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String str1, String str2) {
        // write code here
        //记录最长公共子串substring的长度
        int maxLen = 0;
        //记录最长公共子串最后一个元素在字符串str1中的位置
        int maxLastIndex = 0;
        //辅助变量
        int len1 = str1.length();
        int len2 = str2.length();
        //状态变量：以第i个字符结尾的str1的子串和以第j个字符结尾的str2的子串，包含最后两个元素的两个子串的最长公共子串的长度--也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串（明确状态变量）
        int[][] dp = new int[len1+1][len2+1];
        //遍历数组，通过状态转移方程求出最长公共子串的长度和最长公共子串的最后一个元素的位置
        for(int i = 0; i < len1; i++) {
            for(int j = 0; j < len2; j++) {
                //两个字符相等
                if(str1.charAt(i) == str2.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;//注意这里的下标，不要搞错
                    if(dp[i+1][j+1] > maxLen) {
                        maxLen = dp[i+1][j+1];
                        maxLastIndex = i;//这里记录的是在str中的位置
                    }
                }else {//两个字符不等
                    dp[i + 1][j + 1] = 0;
                }
            }
        }
        //截取原字符串得到结果
        System.out.println(maxLen - maxLastIndex + 1);
        System.out.println(maxLastIndex + 1);
        return str1.substring(maxLastIndex - maxLen + 1, maxLastIndex + 1);//注意这里是左闭右开区间
    }
}
```

## BM67 不同路径的数目

![image-20221012095805826](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221012095805826.png)

起点到终点有多少条路径呢？（只能从起点开始，向下或者向右走，直到终点）

方法一：递归

> **思路：**
>
> 首先我们在左上角第一个格子的时候，有两种行走方式：如果向右走，相当于后面在一个(n−1)∗m的矩阵中查找从左上角到右下角的不同路径数；而如果向下走，相当于后面在一个n∗(m−1)的矩阵中查找从左上角到右下角不同的路径数。而(n−1)∗m的矩阵与n∗(m−1)的矩阵都是n∗m矩阵的子问题，因此可以使用递归。
>
> **具体做法：**
>
> - step 1：**（终止条件）** 当矩阵变长n减少到1的时候，很明显只能往下走，没有别的选择了，只有1条路径；同理m减少到1时也是如此。因此此时返回数量为1.
> - step 2：**（返回值）** 对于每一级都将其两个子问题返回的结果相加返回给上一级。
> - step 3：**（本级任务）** 每一级都有向下或者向右两种路径选择，分别进入相应分支的子问题。

```java
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param m int整型 
 * @param n int整型 
 * @return int整型
 */
int uniquePaths(int m, int n ) {
    // write code here
    if(m == 1 || n == 1) {//此时路径数只有1
        return 1;
    }
    int num = uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
    return num;
}
```

方法二：动态规划

> **思路：**
>
> 如果我们此时就在右下角的格子，那么能够到达该格子的路径只能是它的上方和它的左方两个格子，因此从左上角到右下角的路径数应该是从左上角到它的左边格子和上边格子的路径数之和，因此可以动态规划。
>
> **具体做法：**
>
> - step 1：用`dp[i][j]`表示大小为i∗j的矩阵的路径数量，下标从1开始。
> - step 2：**（初始条件）** 当i或者j为1的时候，代表矩阵只有一行或者一列，因此只有一种路径。
> - step 3：**（转移方程）** 每个格子的路径数只会来自它左边的格子数和上边的格子数，因此状态转移为`dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/59CA06CDCAD5CEBE36459528F0B24D23)

```java
import java.util.*;


public class Solution {
    /**
     *
     * @param m int整型
     * @param n int整型
     * @return int整型
     */
    public int uniquePaths (int m, int n) {
        // write code here
        //定义状态变量dp[i][j]，表示长宽ij的矩阵的路径长度
        int[][] dp = new int[m + 1][n + 1];
        //状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1) { //i=1时，显然只能向右走，只有一种路径
                    dp[i][j] = 1;
                    continue;
                }
                if (j == 1) { //j=1时，显然只能向下走，只有一种路径
                    dp[i][j] = 1;
                    continue;
                }
                //状态转移方程，表示位置[i,j]路径数等于[i-1,j][i,j-1]的路径和
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
```

## BM68 矩阵的最小路径和

求左上到右下的路径和，如图所示：

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/06EB123C153852AF55ED51448BEAD1BA)

方法一：动态规划

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/47BEDBEA9F525B5752D6DB1BE8B0C928)

> **思路：**
>
> 最朴素的解法莫过于枚举所有的路径，然后求和，找出其中最大值。但是像这种有状态值可以转移的问题，我们可以尝试用**动态规划**。
>
> **具体做法：**
>
> - step 1：我们可以构造一个与矩阵同样大小的二维辅助数组，其中`dp[i][j]`表示以[i,j]位置为终点的最短路径和，则`dp[0][0]=matrix[0][0]`。
> - step 2：很容易知道第一行与第一列，只能分别向右或向下，没有第二种选择，因此第一行只能由其左边的累加，第一列只能由其上面的累加。
> - step 3：边缘状态构造好以后，遍历矩阵，补全矩阵中每个位置的dp数组值：如果当前的位置是[i,j]，上一步要么是[i-1,j]往下，要么就是[i,j-1]往右，那么取其中较小值与当前位置的值相加就是到当前位置的最小路径和，因此状态转移公式为`dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + matrix[i][j]`。
> - step 4：最后移动到[m-1,n-1]的位置就是到右下角的最短路径和。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        //状态变量：dp[i][j]表示到达位置[i,j]的最小路径和
        int row = matrix.length;
        int col = matrix[0].length;
        int[][] dp = new int[row][col];
        //dp[i][j]的初始化
        dp[0][0] = matrix[0][0];
        for(int i = 1; i < row; i++) {//第一列，注意这里i从1开始
            dp[i][0] = matrix[i][0] + dp[i - 1][0];
        }
        for(int j = 1 ; j < col; j++) {//第一行
            dp[0][j] = matrix[0][j] + dp[0][j - 1];
        }
        //状态转移
        for(int i = 1; i < row; i++) {
            for(int j = 1; j < col; j++) {
                if(dp[i][j-1] < dp[i-1][j]) {//状态转移方程
                    dp[i][j] = matrix[i][j] + dp[i][j-1];
                }else {
                    dp[i][j] = matrix[i][j] + dp[i-1][j];
                }
            }
        }
        return dp[row - 1][col - 1];
    }
}
```

方法一改进：动态规划

> 原数组matrix和状态数组dp的长宽一样，考虑使用matrix代替dp，但是这样会更改原来的matrix数组

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        //状态变量：dp[i][j]表示到达位置[i,j]的最小路径和
        int row = matrix.length;
        int col = matrix[0].length;
        //状态转移
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                if(i == 0 && j == 0) {
                    continue;
                }
                if(i == 0) {
                    matrix[i][j] += matrix[i][j - 1];
                }else if(j == 0) {
                    matrix[i][j] += matrix[i - 1][j];
                }else {
                    matrix[i][j] += Math.min(matrix[i-1][j],matrix[i][j-1]);
                }
            }
        }
        return matrix[row - 1][col - 1];
    }
}
```

方法三：递归--有点困，暂略。需要用特定数据结构保存中间结果，不然会超时。二刷研究研究吧。

递归方法，明确递归函数定义：从[0,0]到[i,j]的最小路径长度；

根据递归三段式，可写出递归的代码，但是此时代码会超时，为什么呢？

显然中间进行大量的重复运算，我们采用map集合保存中间结果，如果有res，直接取出并返回，如果没有res，将其保存到map集合。

代码如下：--这里本质上和斐波那契数列一样，同样可以选择递归或者更优的动态规划，且动态规划的状态数组可以简化。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    HashMap<String,Integer> map = new HashMap<>();
    public int minPathSum (int[][] matrix) {
        // write code here
        int row = matrix.length;
        int col = matrix[0].length;
        return recursion(matrix,row-1,col-1);
    }
    //递归，函数recursion(...)表示计算左上角到[i,j]的最短路径和
    public int recursion(int[][]matrix, int i, int j) {
        //递归出口
        if(i == 0 && j == 0) {
            return matrix[0][0];
        }
        int res = 0;//保存最短路径和的结果
        //如果有直接从map中取--解决超时问题
        String key = i + "*" + j;
        if(map.containsKey(key)) {
            return map.get(key);
        }
        if(i == 0) {
            res = matrix[i][j] + recursion(matrix,i,j-1);
        }else if(j == 0) {
            res = matrix[i][j] + recursion(matrix,i-1,j);
        }else {
            res = matrix[i][j] + Math.min(recursion(matrix,i,j-1),recursion(matrix,i-1,j));
        }
        map.put(key,res);//将计算过的值放入到map中--解决超时问题
        return res;
    }
}
```

## BM69 把数字翻译成字符串

> **思路：**
>
> 对于普通数组1-9，译码方式只有一种，但是对于11-19，21-26，译码方式有可选择的两种方案，因此我们使用动态规划将两种方案累计。
>
> **具体做法：**
>
> - step 1：用辅助数组dp表示前i个数的译码方法有多少种。
> - step 2：对于一个数，我们可以直接译码它，也可以将其与前面的1或者2组合起来译码：如果直接译码，则dp[i]=dp[i−1];如果组合译码，则dp[i]=dp[i−2]。
> - step 3：对于只有一种译码方式的，选上种dp[i−1]即可，对于满足两种译码方式（10，20不能）则是dp[i−1]+dp[i−2]
> - step 4：依次相加，最后的dp[length]即为所求答案。

这题牛客的解答不是很好，更简单易懂的解答：

https://www.bilibili.com/video/BV1K341117Pm/ 

解答中与BM69不同的是，leetcode是0-25表示a-z，这样0与其他数字的地位相同，而BM69这题，1-26表示a-z，这样0的地位就不同了，体现在“0”本身不能翻译，但是“10”“20”可以翻译，同时“100”“200”之类的不能翻译。所以需要特殊处理。

如图：

![image-20221013122132483](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221013122132483.png)

当然如果选择int[] dp = new int[len+1];，则采用下面的图示：--后来我想了想，貌似没有本质区别，都是先初始化`dp[0]、dp[1]`。

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/46d1fbb9a5943ddc56a48fa52d90447f4cf19467d67e6a44ae9b04dbc9804841-Picture10.png)

```java
import java.util.*;


public class Solution {
    /**
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    public int solve (String nums) {
        // write code here
        int len = nums.length();
        //dp数组：表示前i位可以解码的总数
        int[] dp = new int[len];
        dp[0] = 1;//显然只有1种翻译情况
        //特例判断--针对特定测试用例
        if(nums.equals("0")) return 0;//"0"结果为0
        for(int i = 1; i < len; i++) {//"100"结果为0--当0前面不是1或2时，无法译码（本题难点）
            if(nums.charAt(i) == '0') {
                if(nums.charAt(i-1) != '1' && nums.charAt(i-1) != '2') {
                    return 0;
                }
            }
        }
        //状态转移
        for(int i = 1; i < len; i++) {
            if(nums.charAt(i-1) == '1' && nums.charAt(i) != '0' 
            || nums.charAt(i-1) == '2' && nums.charAt(i) <= '6' && nums.charAt(i) > '0') {//只有这两种情况满足dp[i] = dp[i-1][i-2] 注意，这里需要考虑 10 20的特殊情况
                if(i == 1) {//i==1特殊考虑
                    dp[i] = 2;
                }else {//状态转移方程
                    dp[i] = dp[i-1] + dp[i-2];
                }
            }else {//状态转移方程
                dp[i] = dp[i-1];//官方答案在这里出错，这里代码也是错的，比如“120”，代码输出2，其实是1
            }
        }
        //返回
        return dp[len-1];
    }
}
```

这题写的有点乱，仔细想想还是1.定义状态参数；2.初始化部分状态参数；3.状态转移填满状态数组；4.从状态数组中得到结果。

这题官方答案也有问题，推荐还是看leetcode上的数字翻译，同时后面也研究下为啥每次状态数组长度都定义成len+1

## BM70 兑换零钱

方法一：动态规划

该方法没有找到非常好的图，这个图已经很详细了。来自b站：https://www.bilibili.com/video/BV13f4y1e7vL/

![image-20221013173344345](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221013173344345.png)

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // write code here
        //状态数组：dp[i]表示凑成面值i所需要的最小零钱数目
        int[] dp = new int[aim+1];
        //状态初始化
        Arrays.fill(dp,aim+1);
        dp[0] = 0;
        //状态转移--填数组的过程
        for(int i = 1; i < dp.length; i++) {
            for(int j = 0; j < arr.length; j++) {
                if(i >= arr[j]) {//注意：目标面值需要大于等于零钱
                    dp[i] = Math.min(dp[i], dp[i-arr[j]] + 1);//状态转移方程dp[i]=min(dp[i-arr[j]]+1)
                }
            }
        }
        return dp[aim] == aim + 1 ? -1 : dp[aim];
    }
}
```

方法二：记忆化搜索

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/C717E3CAF4B26554221532DD4BC6BB1E)

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // write code here
        int[] dp = new int[aim + 1];//记录中间变量，记忆化递归
        return recursion(arr,aim,dp);//返回需要的零钱数量
    }
    //返回：需要的零钱数目
    //参数：arr:零钱数组 aim:当前面值 dp:保存面值i需要的最少零钱数
    public int recursion(int[] arr, int aim, int[] dp) {
        //递归出口
        //当前面值为0需要的零钱数
        if(aim == 0) {
            return 0;//正好凑出面值
        }
        //当前面值为负需要的零钱数
        if(aim < 0) {
            return -1;//无法凑出面值
        }
        //直接查找数组，是否已经计算过
        if(dp[aim] != 0) {
            return dp[aim];
        }
        //当前任务
        //遍历零钱
        int min = aim;//记录最小的零钱数
        for(int i = 0; i < arr.length; i++) {
            int res = recursion(arr,aim - arr[i],dp);//计算子过程需要的最小零钱数
            if(res >= 0) {//排除res==-1的情况
                min = Math.min(min,res+1);//更新最小零钱数目
            }  
        }
        //更新记忆数组
        dp[aim] = (min == aim) ? -1 : min;
        return dp[aim];
    }
}
```

## BM71 最长上升子序列

本题是动态规划里非常经典的一道题，难度也不大，可以尝试从状态数组和状态方程两个角度思考，画出图像。

下面给出状态数组的图示：

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/E86C643E2CD0E3FBCFED92B006AB9473)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 给定数组的最长严格上升子序列的长度。
     * @param arr int整型一维数组 给定的数组
     * @return int整型
     */
    public int LIS (int[] arr) {
        // write code here
        //特例
        if(arr.length == 1) {
            return 1;
        }
        if(arr.length == 0) {
            return 0;
        }
        //状态数组：以arr[i]元素为结尾的最长上升子序列长度
        int[] dp = new int[arr.length];
        Arrays.fill(dp,1);//初始化
        int res = 0;//保存最长上升子序列
        //状态转移
        for(int i = 1; i < arr.length; i++) {
            for(int j = 0; j < i; j++) {//这里遍历到arr[i]即可
                if(arr[i] > arr[j] && dp[i] < dp[j] + 1) {//满足递增和更长两个条件
                    dp[i] = dp[j] + 1;//状态方程
                    res = Math.max(res,dp[i]);//保存最长的长度
                }
            }
        }
        return res;
    }
}
```

## BM72 连续子数组的最大和

方法一：动态规划

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1E482BB5A244FA3CE63D9A194AC1C4D4)

> 动态规划，设动态规划列表 dp，dp[i] 代表以元素 array[i] 为结尾的连续子数组最大和。
>
> 状态转移方程： dp[i] = Math.max(dp[i-1]+array[i], array[i]);
>
> 具体思路如下：
> 1.遍历数组，比较 dp[i-1] + array[i] 和 array[i]的大小;
> 2.为了保证子数组的和最大，每次比较 sum 都取两者的最大值;
> 3.用max变量记录计算过程中产生的最大的连续和dp[i]；

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        //状态数组:以Array[i]为结尾的数组的“连续子数组的最大和”
        int[] dp = new int[array.length];
        //初始化
        dp[0] = array[0];
        //最值
        int max = array[0];
        //填表
        for(int i = 1; i < array.length; i++) {
            if(dp[i - 1] > 0) {
                dp[i] = dp[i - 1] + array[i];
            }else {
                dp[i] = array[i];
            }
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}

```

方法一改进：优化动态规划

> 我们可以简化动态规划，使用一个变量sum来表示当前连续的子数组和，以及一个变量max来表示中间出现的最大的和。

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        //状态数组:以Array[i]为结尾的数组的“连续子数组的最大和”
        //int[] dp = new int[array.length];
        //初始化
        //dp[0] = array[0];
        int sum = 0;
        //最值
        int max = array[0];
        //填表
        for(int i = 0; i < array.length; i++) {
            sum = Math.max(array[i],sum+array[i]);//优化动态规划，确定sum最大值
            max = Math.max(max,sum);//保存出现的最大值
        }
        return max;
    }
}
```

## BM73 最长回文子串

本题参考解答：[史上最燃算法刷题！Leetcode 5. 最长回文子串_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1dN4y1g7p9/)

方法一：暴力求解

截取字符串的所有子串，判断子串是否是回文串，保存最长的回文串子串。

优化点：如果截取的子串小于目前保存的最长回文子串，则不需要判断该子串是否是回文串，因为即使它是回文串也不是最长回文串

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    public int getLongestPalindrome (String A) {
        // write code here
        String res = A.substring(0,1);//截取的最长回文子串
        //截取字符串所有的子串
        for(int i = 0; i < A.length(); i++) {
            for(int j = i + 1; j < A.length(); j++) {
                //判断子串是否是回文串，并且子串大于已经保存的子串长度
                //优化点：如果截取的子串长度小于目前的最长回文子串，可以直接跳过
                //因为即使它是回文子串，也不可能是最长的
                if((j - i + 1) > res.length() && solve(A,i,j)) {
                    res = A.substring(i,j+1);
                }
            }
        }
        return res.length();
    }
    //判断str里的[i,j]是否为回文子串--注意这里不是判断[i,j]内是否存在回文子串
    public boolean solve(String str, int left, int right) {
        while(left <= right) {
            if(str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

方法二：动态规划

![image-20221015005616604](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221015005616604.png)

本题的解答视频：https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/

liweiwei大佬讲的十分透彻，详细解释了填表的过程中，需要先填写左下角的原因。

再次探讨了，动态规划本质上就是一个清晰定义状态方程，找到状态转移规律，进行填表的过程。

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    public int getLongestPalindrome (String A) {
        // write code here
        //状态数组：dp[i][j]表示字符串A.substring(i,j+1)是否是回文串
        int len = A.length();
        boolean[][] dp = new boolean[len][len];//注意：java中boolean的默认值是false
        //初始化状态数组
        for(int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        //记录回文串长度
        int res = 1;
        //填表--这里需要画图理解，为什么填表的上半部分？
        //因为dp[i][j]的状态与dp[i+1][j-1]有关，显然要先填dp[i+1][j-1]
        for(int j = 1; j < len; j++) {
            for(int i = 0; i < j; i++) {
                //状态转移
                if(A.charAt(i) != A.charAt(j)) {//左右字符不相等，显然不是回文串
                    dp[i][j] = false;
                }else {//A.charAt(i) == A.charAt(j)
                    if(j - i + 1 <= 3) {//左右字符相等时，串长度小于等于3，显然是回文串
                        dp[i][j] = true;
                    }else {//左右字符相等时，字符串是否是回文串取决于去掉左右字符后的子串是否是回文串
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && j - i + 1 > res) {//字符串是回文子串，且长度大于保存的最大长度，更新最大长度
                    res = j - i + 1;
                    //res = Math.max(res,j-i+1); //常用的求最大最小值的写法
                }

            }
        }
        return res;
    }
}
```

方法三：中心扩展算法 暂略

方法四：马拉车算法 暂略

## BM74 数字字符串转化为ip地址

方法一：回溯

![image-20221015114347454](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221015114347454.png)

参考leetcode官方题解写的，官解简单易懂，但是有个严重的问题，高度耦合，代码逻辑比较复杂，很容易出错。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return string字符串ArrayList
     */
    ArrayList<String> res = new ArrayList<>();//保存最终结果，多个ip地址
    //ArrayList<String> path = new ArrayList<>();//保存中间结果，单个ip地址
    // int segStart = 0;//表示每个ip段在原字符串的起始位置
    // int segIndex = 0;//取值0123，表示共4个ip段
    int[] segment = new int[4];//表示每个ip段的数字
    public ArrayList<String> restoreIpAddresses (String s) {
        // write code here
        dfs(s,0,0);
        return res;       
    }
    //树形递归
    //segStart表示ip段在字符串中的起始位置
    //segIndex表示实际遍历到第几个ip段，取值1234
    public void dfs(String s, int segStart, int segIndex) {
        //递归出口：遍历完第4个ip段
        if(segIndex == 4) {//segIndex==4表示遍历完4个ip段
            if(segStart == s.length()) {
                //遍历segment数组，找出ip段拼接--拼接过程需要借助StringBuffer，减少消耗
                StringBuffer sb = new StringBuffer();
                for(int i = 0; i < segIndex; i++) {
                    sb.append(segment[i]);
                    if(i != 3) {
                        sb.append(".");
                    }
                }
                //将一种结果填充进res
                res.add(sb.toString());
            }
            return ;
        }
        //没有找到4个ip段就遍历完字符串，提前返回（剪枝）
        if(segStart == s.length()) {
            return ;
        }
        //ip段首位为0单独处理，当前数字为0，该ip段只能为0
        if(s.charAt(segStart) == '0') {
            segment[segIndex] = 0;
            dfs(s, segStart + 1, segIndex + 1);
        }
        //本级任务，枚举每一种可能性并且递归--本题难点
        //这里的一个难点在于如何巧妙的截取字符串成为数字，虽然substring方法可以但显然性能消耗很大。
        int temp = 0;
        for(int segEnd = segStart; segEnd < s.length(); segEnd++) {
            temp = 10 * temp + (s.charAt(segEnd) - '0');//ip段数字大小，这里的方法很巧妙
            if(temp > 0 && temp <= 255) {
                segment[segIndex] = temp;
                dfs(s,segEnd + 1,segIndex + 1);
            }else {//ip段超过0-255的范围，剪枝
                break;//这里等同于直接return
            }
        }
    }
}
```

回溯的另外写法：个人认为该方法更实用一些，完全按照回溯的写法来写的。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/0EF05BBD11A798D5A7E5201B73F6430E)

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return string字符串ArrayList
     */
    ArrayList<String> res = new ArrayList<>();//结果集合
    String ip = "";//可能的ip地址
    public ArrayList<String> restoreIpAddresses (String s) {
        // write code here
        dfs(s,0,0);
        return res;
    }
    //树形递归
    //index：遍历字符串的下标
    //step：遍历到第几个ip段0123
    public void dfs(String s, int index, int step) {
        //当前分割的字符串
        String cur = "";
        //递归出口：step == 4 && index == s.length()
        if(step == 4) {//注意这里是4不是3，当step==4时，表示前面已经分割出了4个ip段0123
            if(index == s.length()) {
                res.add(ip);
            }else {
                return ;//剪枝操作，已经有4个ip段但还没有遍历完字符串
            }
        }
        //本级任务
        for(int i = index; i - index + 1 <= 3 && i < s.length(); i++) {
            //保存当前分割的字符串
            cur += s.charAt(i);
            //将该字符串转成数字
            int num = Integer.parseInt(cur);
            //临时变量保存当前ip地址
            String temp = ip;
            //判断当前分割的字符串是否满足：不超过255且没有前导0
            //错误条件：(num > 0 && num < 255) || (cur.length() == 1 && num == 0)
            if(num <= 255 && (cur.length() == 1 || cur.charAt(0) != '0')) {
                if(step == 3) {//只有3个分割号
                    ip += cur;
                }else {
                    ip += cur + ".";
                }
                //递归查找下一个ip段
                dfs(s,i+1,step+1);
                //回溯
                ip = temp;//这里必须回溯，因为ip的状态在递归内已经被修改，回到进入递归前的状态
            }
        }
        
    }
}
```

## BM75 编辑距离 *

leetcode解答：https://leetcode.cn/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/DD11C7A67C32B75B31F944921631AC97)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param str1 string字符串 
     * @param str2 string字符串 
     * @return int整型
     */
    public int editDistance (String str1, String str2) {
        // write code here
        int len1 = str1.length();
        int len2 = str2.length();
        //定义状态数组 dp[i][j]表示str1[1...i]与str2[1...j]的编辑距离（修改的字符个数）
        int[][] dp = new int[len1 + 1][len2 + 1];
        //初始化状态数组
        for(int i = 1; i <= len1; i++) {
            dp[i][0] = dp[i - 1][0] + 1;
        }
        for(int j = 1; j <= len2; j++) {
            dp[0][j] = dp[0][j - 1] + 1;
        }
        //填表
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                if(str1.charAt(i - 1) == str2.charAt(j - 1)) {//字符相等，无需修改
                    dp[i][j] = dp[i - 1][j - 1];
                }else {//字符不等，需要修改、增加或者删除
                    //修改dp[i][j] = dp[i - 1][j - 1] + 1;
                    //增加dp[i][j] = dp[i - 1][j] + 1;
                    //删除dp[i][j] = dp[i][j - 1] + 1;
                    dp[i][j] = Math.min(dp[i-1][j - 1],Math.min(dp[i][j-1],dp[i-1][j])) + 1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```



## BM76 正则表达式匹配 *

方法1：动态规划

这题状态方程太复杂了，给我整懵逼了。看答案写的解答。

又回头看了一遍，这题是真的离谱，看起来简单，但是有些地方是真的不理解，草！

参考链接：https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-s3jgn/

参考链接：https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param str string字符串
     * @param pattern string字符串
     * @return bool布尔型
     */
    public boolean match (String str, String pattern) {
        // write code here
        int n1 = str.length();
        int n2 = pattern.length();
        //dp[i][j]为true表示str的前i个字符与pattern的前j个字符相匹配
        boolean[][] dp = new boolean[n1 + 1][n2 + 1];
        //遍历str的长度
        for (int i = 0; i <= n1; i++) {
            //遍历pattern的长度
            for (int j = 0; j <= n2; j++) {
                if (j == 0) { //空pattern的情况
                    dp[i][j] = (i == 0) ? true : false;//初始条件
                } else {
                    //没有遇到*的情况
                    if ((i >= 1 && j >= 1) && (str.charAt(i - 1) == pattern.charAt(j - 1) ||
                                               pattern.charAt(j - 1) ==
                                               '.')) {//两个字符相等或pattern用.匹配任意一个字符
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {//剩下的是遇到*的情况（比较复杂，本题难点）
                        if (j >= 2) { //无论是否匹配，都可以将a*匹配原字符0次
                            dp[i][j] = dp[i][j - 2];
                            if ((i >= 1 && j >= 2) && (pattern.charAt(j - 2) == '.' ||
                                                       str.charAt(i - 1) == pattern.charAt(j - 2))) {//能匹配，表示多个字符
                                dp[i][j] = dp[i - 1][j] || dp[i][j - 2];//pattern为.*或者为a*
                            }
                        }
                        
                    }
                }
            }
        }
        return dp[n1][n2];

    }
}
```



## BM77 最长的括号子串

只能说，这题看起来简单，但栈的做法不符合常识。

方法1：栈

> 一个合法的括号序列需要满足以下两个条件：
>
> 1. 任意前缀中左括号的数量 ≥≥ 右括号的数量；
> 2. 左右括号数量相等。
>
> 因此可以根据首次不合法的右括号（右括号数量首次大于左括号数量的位置）将原字符串划分成多段，可以看出，最长有效括号一定在段内产生；之后在每一段内找到所有合法括号序列，求出最大值即可。具体算法如下：
>
> 1. 遇到左括号，将下标入栈；
> 2. 遇到右括号：
>    1. 如果栈不空，将栈顶元素出栈，与当前右括号匹配：
>       1. 出栈后栈不空，则栈顶元素的下一个位置开始即为合法序列；
>       2. 出栈后栈为空，则当前段起始点开始都为合法序列；
>    2. 如果栈为空，说明此时右括号为首次不合法的右括号，更新段起始位置。
>
> 一个很好的例子是：) ( ( ( ) ) ) ( ( ( )
>
> 参考链接：https://blog.lichangao.com/daily_practice/leetcode/stack/push_match.html#_0032-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return int整型
     */
    public int longestValidParentheses (String s) {
        // write code here
        //结果
        int res = 0;
        //栈
        Stack<Integer> stack = new Stack<>();
        //记录上一次连续括号的结束位置
        int start = -1;
        //遍历字符串
        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if(ch == '(') {//遍历到左括号，下标入栈--这里入栈的不是左右括号而是下标
                stack.push(i);
            }else {//遍历到右括号
                if(stack.empty()) {//栈为空（难点1：表示开始计算下一段括号子串长度）
                    start = i;
                }else {//栈不为空
                    stack.pop();
                    if(stack.isEmpty()) {//弹出匹配的括号对后栈为空，当前段起始点开始均为合法序列
                        res = Math.max(res, i - start);
                    }else {//弹出匹配的括号对后栈不为空，栈顶元素的下一个位置开始为合法序列
                        res = Math.max(res, i - stack.peek());
                    }
                }
            }
        }
        return res;
    }
}
```

##  BM78 打家劫舍（一）

方法1：动态规划

> - step 1：用dp[i]表示长度为i的数组，最多能偷取到多少钱，只要每次转移状态逐渐累加就可以得到整个数组能偷取的钱。
> - step 2：**（初始状态）** 如果数组长度为1，只有一家人，肯定是把这家人偷了，收益最大，因此dp[1] = nums[0]。
> - step 3：**（状态转移）** 每次对于一个人家，我们选择偷他或者不偷他，如果我们选择偷那么前一家必定不能偷，因此累加的上上级的最多收益，同理如果选择不偷他，那我们最多可以累加上一级的收益。因此转移方程为dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1])。这里的i在dp中为数组长度，在nums中为下标。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/D62F0F8E64BE644381DF7ED781BB95C4)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @return int整型
     */
    public int rob (int[] nums) {
        // write code here
        //dp[i]表示长度为i的数组，最多能偷多少钱
        int n = nums.length;
        int[] dp = new int[n + 1];//状态变量
        //长度为1只能偷第一家
        dp[0] = 0;
        dp[1] = nums[0];//初始化状态变量
        //遍历金钱数组
        for(int i = 2; i <= n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);//状态转移
        }
        return dp[n];
    }
}
```



## BM79 打家劫舍（二）

方法1：动态规划

> 第一家与最后一家不能同时取到，那么我们可以分成两种情况讨论：
>
> - 情况1：偷第一家的钱，不偷最后一家的钱。初始状态与状态转移不变，只是遍历的时候数组最后一位不去遍历。
> - 情况2：偷最后一家的请，不偷第一家的钱。初始状态就设定了dp[1] = 0，第一家就不要了，然后遍历的时候也会遍历到数组最后一位。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/08FD65C59C7CBF1EE7EC90873A386B7D)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @return int整型
     */
    public int rob (int[] nums) {
        // write code here
        //核心：第一家和最后一家不能同时偷，分类讨论
        int n = nums.length;
        int[] dp = new int[ n + 1 ];//状态数组：dp[i]表示长度i的数组最多能偷的钱
        dp[0] = 0;
        dp[1] = nums[0];
        //不偷最后一家 dp[n - 1] == dp[n]
        for(int i = 2; i < n; i++) {//注意下标
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        int res1 = dp[n - 1];
        //不偷第一家 dp[1] = 0
        Arrays.fill(dp,0);
        dp[1] = 0;//注意初始值
        for(int i = 2; i <= n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        int res2 = dp[n];
        return Math.max(res1, res2);
    }
}
```

## BM80 买卖股票的好时机（一）

方法1：暴力解法

两层for循环，找到数组中的最大差值，表示利润最大化。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int res = 0; 
        for(int i = 0; i < prices.length; i++) {
            for(int j = i + 1; j < prices.length; j++) {
                int temp = prices[j] - prices[i];
                res = Math.max(res, temp);
            }
        }
        return res;
    }
}
```

方法2：优化方法1，贪心算法

贪心算法属于动态规划算法的一种，基本原理是找出整体当中局部子结构的最优解，将所有最优解结合起来形成整体上的最优解。

> 对应本题思路就是，遍历股价数组，每次遍历都求当前的最大收益，直到遍历完成整个股价数组，此最大收益即为最优解，
>
> 为了求当前的最大收益，我们需要定义一个变量min，该变量记录了当前遍历过的股价数组中的最小股价，当前最大收益即用当前股价减去最小股价。
>
> - step 1：首先排除数组为空的特殊情况。
> - step 2：将第一天看成价格最低，后续遍历的时候遇到价格更低则更新价格最低。
> - step 3：每次都比较最大收益与当日价格减去价格最低的值，选取最大值作为最大收益。

![image-20230222153220530](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/image-20230222153220530.png)

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/DC748AB84FD5FA876AEC8EAF47CC0C9D)

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int res = 0; 
        int len = prices.length;
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < len; i++) {
            if(prices[i] <= min) {
                min = prices[i];//min保存当前最小值
            }else {
                res = Math.max(res,prices[i] - min);//记录当前股价差，大于res则保存
            }
        }
        return res;
    }
}
```

方法3：动态规划

> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> `dp[i][0]`表示第i天的收益(第i天不持股)，`dp[i][1]`表示第i天收益（第i天持股）

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        //dp[i][0]表示第i天的收益(第i天不持股)，dp[i][1]表示第i天收益（第i天持股）
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);//今天不持股的收益，等于昨天不持股的收益or昨天持股今天卖出的收益
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);//今天持股的收益，等于昨天持股的收益or昨天不持股今天买进的收益
        }
        return dp[n - 1][0];//最后一天不能持股
    }
}
```



## **BM81** 买卖股票的好时机（二）

方法1：动态规划

动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/5DD0E1F211FF54BE02A4C72B07C8D44E)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型一维数组 股票每一天的价格
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int n = prices.length;
        //状态变量：dp[i][0]表示到i天的收益（未持股），dp[i][1]表示到i天的收益（持股）
        int[][] dp = new int[n][2];
        //初始化
        dp[0][0] = 0;
        dp[0][1] = - prices[0];
        //状态转移
        for(int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];//最后一天不能持股
    }
}
```

方法2：贪心

贪心思想属于动态规划思想中的一种，其基本原理是找出整体当中给的每个局部子结构的最优解，并且最终将所有的这些局部最优解结合起来形成整体上的一个最优解。

> 其实我们要想获取最大收益，只需要在低价买入高价卖出就可以了，因为可以买卖多次。利用贪心思想：只要一段区间内价格是递增的，那么这段区间的差值就是我们可以有的收益。

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型一维数组 股票每一天的价格
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int n = prices.length;
        int res = 0;
        for(int i = 1; i < n; i++) {
            if(prices[i] > prices[i - 1]) {
                res += prices[i] - prices[i - 1];
            }
        }
        return res;
    }
}
```



## BM82 买卖股票的好时机（三）

方法1：动态规划

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/8C61C80AE17960D42B310FDF74C56E12)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 两次交易所能获得的最大收益
     * @param prices int整型一维数组 股票每一天的价格
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        //dp[i][]表示到i天为止的收益
        //dp[i][0]没有买过
        //dp[i][1]买过一次
        //dp[i][2]买过一次，卖过一次
        //dp[i][3]买过两次，卖过一次
        //dp[i][4]买过两次，卖过两次
        int n = prices.length;
        //状态数组
        int[][] dp = new int[n][5];
        //初始化状态数组
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        //状态转移
        for(int i = 1; i < n; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        int res = Math.max(dp[n - 1][2], dp[n - 1][4]);
        return res;
    }
}
```

这里可以利用变量对状态数组进行优化，详见：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/

```java
class Solution {
    public int maxProfit(int[] prices) {
        //stock0没有买过
        //stock1买过一次
        //stock2买过一次，卖过一次
        //stock3买过两次，卖过一次
        //stock4买过两次，卖过两次
        int n = prices.length;
        //状态数组
        //int[][] dp = new int[n][5];
        //初始化状态变量
        int stock0 = 0;
        int stock1 = -prices[0];
        int stock2 = 0;
        int stock3 = -prices[0];
        int stock4 = 0;
        //状态转移
        for(int i = 1; i < n; i++) {
            //stock0 = 0;
            stock1 = Math.max(stock1, stock0 - prices[i]);
            stock2 = Math.max(stock2, stock1 + prices[i]);
            stock3 = Math.max(stock3, stock2 - prices[i]);
            stock4 = Math.max(stock4, stock3 + prices[i]);
        }
        //int res = Math.max(stock2, stock4);
        //哪怕stock2结果最大，最终也会转移到stock4，所以直接返回stock4即可。
        //当然也可以理解为，进行一次交易后获得最优解，后面只需要每天进行买进卖出即可。
        return stock4;
    }
}
```

