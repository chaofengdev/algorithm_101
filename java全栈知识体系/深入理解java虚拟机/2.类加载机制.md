[TOC]

## 类的生命周期

`类加载`的过程包括`加载`、`验证`、`准备`、`解析`、`初始化`五个阶段。

在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。

解析阶段可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定。

另外注意这里的几个阶段是按顺序开始，但是不一定按照顺序完成，这些阶段都是相互交叉地混合进行的，通常在一个阶段执行的过程中调用激活另一个阶段。

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/java_jvm_classload_2.png)

### 加载：查找并加载类的二进制数据

ps:区分`加载`与`类加载`，加载只是类加载的第一步。

`加载`（Loading）是`类加载`（Class Loading）过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

- 通过类的全限定名来获取定义的二进制字节流。
- 将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/java_jvm_classload_1.png)

加载阶段（获取类的二进制字节流的动作）是可控性最强的一个阶段，因为我们既可以使用系统提供的类加载器进行加载，也可以自定义类加载器进行加载。

加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机规定的格式存储在方法区（方法区中的数据结构完全由虚拟机实现自定义，《Java虚拟机规范》没有规定此区域的具体数据结构），同时在堆内存中创建一个java.lang.Class类型的对象，通过该对象访问方法区中的这些数据。

JVM规范允许类加载器在预料到某个类将要被使用时提前加载，如果在预先加载的过程中遇到了xx.class文件缺失或错误，类加载器只会在程序首次主动使用该类时才报告错误。即如果该类一直没有被使用，那么类加载器不会报告错误。

下面是加载xx.class文件的方式：

- 将Java源文件动态编译为字节码文件
- 从本地系统中直接加载
- 通过网络下载字节码文件
- 从zip，jar等归档文件中加载字节码文件
- 从专有数据库中提取字节码文件--这个场景比较少见，没有见过。

加载阶段与连接阶段的部分动作是交叉进行的，如一部分字节码文件格式的验证工作。加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然是连接阶段的一部分，这两个阶段的开始时间仍然保持固定的先后顺序。

### 连接（验证、准备、解析）

#### 验证：确保被加载类的正确性

验证是连接阶段的第一步，验证的目的是确保Class文件中的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

Java语言本身是比较安全的语言，使用Java代码很难做到一些比较危险的操作，那么为什么还要验证字节流的正确性呢？这是因为Class文件并不一定是Java源码编译生成，它可以有很多途径生成，比如可以直接使用01直接编辑生成Class文件，Java源码不能实现的危险操作在字节码层面上是完全可以实现的。虚拟机如果对输入的字节流完全信息，很可能因为载入有恶意企图的字节流导致系统受到攻击，所以对字节流进行验证是一项必要措施。

验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能够承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占据相当大的比重。但如果类经过反复验证，可以考虑采用-Xverifynone参数来关闭大部分类验证措施，缩短虚拟机类加载时间。

验证阶段大致上会完成四个阶段的检验工作：

- 文件格式验证：验证字节流是否符合Class文件格式的规范。比如，是否以魔数开头，主次版本号是否在虚拟机的处理范围内，常量池中的常量是否有不被支持的类型；
- 元数据验证：

