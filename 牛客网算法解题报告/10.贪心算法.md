## BM95 分糖果问题

方法1：贪心算法

> 既然要求每个孩子初始都有一个糖果，不如直接使用一个数组，保存每个孩子分得的糖果数量，同时初始化数组所有元素为1
>
> 对例子892347318来说：
>
> 从左到右遍历，只要右边孩子比左边孩子得分高，我们就将右边孩子糖果数量加1；
>
> 但上面只能解决得分递增时糖果分配，对731来说，孩子分得的糖果分别是411，显然3大于1，但是糖果数量却没有更多，
>
> 解决方案是从右到左遍历，遇到左边孩子得分大于右边孩子，【并且左边孩子糖果数量小于等于右边孩子】，我们将左边糖果数量加1.
>
> 梳理以上思路：
>
> - step 1：使用一个辅助数组记录每个位置的孩子分到的糖果，全部初始化为1.
> - step 2：从左到右遍历数组，如果右边元素比相邻左边元素大，意味着在递增，糖果数就是前一个加1，否则保持1不变。
> - step 3：从右到左遍历数组，如果左边元素比相邻右边元素大， 意味着在原数组中是递减部分，如果左边在上一轮中分到的糖果数更小，则更新为右边的糖果数+1，否则保持不变。
> - step 4：将辅助数组中的元素累加求和。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/A8400E6DCC3AEA3DA7A76AE52585741A)

```java
import java.util.*;


public class Solution {
    /**
     * pick candy
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int candy (int[] arr) {
        // write code here
        //贪心算法
        //糖果数组：记录每个孩子分到的糖果数量
        int[] temp = new int[arr.length];
        for(int i = 0; i < arr.length; i++) {
            temp[i] = 1;
        }
        //从左到右遍历，每次右边得分比左边高，则右边糖果数量加1
        for(int i = 1; i < arr.length; i++) {
            if(arr[i] > arr[i - 1]) {
                temp[i] = temp[i - 1] + 1;
            }
        }
        //从右向左遍历，每次左边得分比右边高，但左边糖果数量更少，则左边糖果数量加1
        for(int j = arr.length - 2; j >= 0; j--) {
            if(arr[j] > arr[j + 1] && temp[j] <= temp[j + 1]) {//糖果数量一样或者更少
                temp[j] = temp[j + 1] + 1;
            }
        }
        //求糖果数量
        int res = 0;
        for(int k = 0; k < temp.length; k++) {
            res += temp[k];
        }
        return res;
    }
}
```

> 一点写法上的优化。
>
> 求糖果数量可以放在上一个for循环中一起完成，同时上一个从右向左的遍历，temp[j]本质上是求Math.max(temp[j], temp[j + 1] + 1)
>
> 翻译成人话就是，如果糖果本来就多，那就不动，如果糖果小于右边，那糖果数量就是右边加1

```java
import java.util.*;


public class Solution {
    /**
     * pick candy
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int candy (int[] arr) {
        // write code here
        //贪心算法
        //糖果数组：记录每个孩子分到的糖果数量
        int[] temp = new int[arr.length];
        for(int i = 0; i < arr.length; i++) {
            temp[i] = 1;
        }
        //从左到右遍历，每次右边得分比左边高，则右边糖果数量加1
        for(int i = 1; i < arr.length; i++) {
            if(arr[i] > arr[i - 1]) {
                temp[i] = temp[i - 1] + 1;
            }
        }
        //从右向左遍历，每次左边得分比右边高，但左边糖果数量更少，则左边糖果数量加1
        int res = temp[arr.length - 1];
        for(int j = arr.length - 2; j >= 0; j--) {
            if(arr[j] > arr[j + 1]) {
                temp[j] = Math.max(temp[j], temp[j + 1] + 1);
            }
            res += temp[j];
        }
        return res;
    }
}
```

