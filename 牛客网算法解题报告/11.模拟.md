## BM97 旋转数组

方法1：三次翻转

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/3E6A48137367D997F49AB13EF302653A)

```java
import java.util.*;


public class Solution {
    /**
     * 旋转数组
     * @param n int整型 数组长度
     * @param m int整型 右移距离
     * @param a int整型一维数组 给定数组
     * @return int整型一维数组
     */
    public int[] solve (int n, int m, int[] a) {
        // write code here
        //三次反转
        //取余，每次长度为n的旋转数组相当于没有变化
        m = m % n;
        //特例
        if(m == 0) {
            return a;
        }
        if(m == n) {
            reverse(a, 0, n - 1);
            return a;
        }
        //反转整个数组
        reverse(a, 0, n - 1);

        //反转左半部分
        reverse(a, 0, m - 1);
        //反转右半部分
        reverse(a, m, n - 1);
        return a;
    }
    //反转数组元素
    public void reverse(int[] arr, int left, int right) {
        while(left < right) {//思考下这里为什么不用for循环，或者用for循环应该怎么做
            //交换头尾元素，实现反转
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            //更新指针
            left++;
            right--;
        }
    }
}
```

下面给出一点更改while循环的写法。

```java
import java.util.*;


public class Solution {
    /**
     * 旋转数组
     * @param n int整型 数组长度
     * @param m int整型 右移距离
     * @param a int整型一维数组 给定数组
     * @return int整型一维数组
     */
    public int[] solve (int n, int m, int[] a) {
        // write code here
        //三次反转
        //取余，每次长度为n的旋转数组相当于没有变化
        m = m % n;
        //特例
        if(m == 0) {
            return a;
        }
        if(m == n) {
            reverse(a, 0, n - 1);
            return a;
        }
        //反转整个数组
        reverse(a, 0, n - 1);

        //反转左半部分
        reverse(a, 0, m - 1);
        //反转右半部分
        reverse(a, m, n - 1);
        return a;
    }
    //反转数组元素
    public void reverse(int[] arr, int left, int right) {
        for(int i = 0; i < (right - left + 1) / 2; i++) {//注意这里下标的写法
            int temp = arr[left + i];
            arr[left + i] = arr[right - i];
            arr[right - i] = temp;
        }
    }
}
```



## BM98 螺旋数组

方法1：边界模拟法

> 这道题就是一个简单的模拟，我们想象有一个矩阵，从第一个元素开始，往右到底后再往下到底后再往左到底后再往上，结束这一圈，进入下一圈螺旋。
>
> - step 1：首先排除特殊情况，即矩阵为空的情况。
> - step 2：设置矩阵的四个边界值，开始准备螺旋遍历矩阵，遍历的截止点是左右边界或者上下边界重合。
> - step 3：首先对最上面一排从左到右进行遍历输出，到达最右边后第一排就输出完了，上边界相应就往下一行，要判断上下边界是否相遇相交。
> - step 4：然后输出到了右边，正好就对最右边一列从上到下输出，到底后最右边一列已经输出完了，右边界就相应往左一列，要判断左右边界是否相遇相交。
> - step 5：然后对最下面一排从右到左进行遍历输出，到达最左边后最下一排就输出完了，下边界相应就往上一行，要判断上下边界是否相遇相交。
> - step 6：然后输出到了左边，正好就对最左边一列从下到上输出，到顶后最左边一列已经输出完了，左边界就相应往右一列，要判断左右边界是否相遇相交。
> - step 7：重复上述3-6步骤直到循环结束。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/34EC0DBACF8E56532AF5EE41BC84C258)

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> spiralOrder(int[][] matrix) {
        //遍历螺旋矩阵
        //结果集合
        ArrayList<Integer> res = new ArrayList<>();
        //特殊情况
        if(matrix.length == 0) return res;
        //设置遍历矩阵的边界值
        int left = 0; 
        int right = matrix[0].length - 1;
        int up = 0;
        int down = matrix.length - 1;
        //螺旋遍历二维矩阵
        while(left <= right && up <= down) {
            //从左到右遍历
            for(int i = left; i <= right; i++) {
                res.add(matrix[up][i]);
            }
            up++;//上边界下移
            if(up > down) {//判断上下边界是否相交
                break;
            }
            //从上到下遍历
            for(int i = up; i <= down; i++) {
                res.add(matrix[i][right]);
            }
            right--;
            if(right < left) {
                break;
            }
            //从右到左遍历
            for(int i = right; i >= left; i--) {
                res.add(matrix[down][i]);
            }
            down--;
            if(up > down) {//注意这里的大小关系
                break;
            }
            //从下到上遍历
            for(int i = down; i >= up; i--) {
                res.add(matrix[i][left]);
            }
            left++;
            if(left > right) {
                break;
            }
        }
        return res;
    }
}
```



## BM99 顺时针旋转矩阵

方法1：找到相关规律，直接模拟

难得写了个比原答案还简单的解答。但是显然不是原地交换，稍微修改一下就是原地交换。

```java
 import java.util.*;

public class Solution {
    public int[][] rotateMatrix(int[][] mat, int n) {
        // write code here
        int[][] res = new int[n][n];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                res[j][n - 1 - i] = mat[i][j];
            }
        }
        return res;
    }
}
```

注意：上面的式子是不能改造完成原地交换的，举例如下。

只看左上角的矩阵，按照上面的对应关系，1会换到3的位置，而3本来应该换到9的位置，现在却跑到了1的位置。

所以不借助缓存数组的情况下，不能简单进行交换。

![image-20230219003230415](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/image-20230219003230415.png)

方法2：转置

遇到二维矩阵的旋转之类的题，首先想到转置来解决。

深刻理解一下转置，本质上就是围着主对角线交换对应元素，可以发现正好是第一行放第一列，第二行放第二列等等，

题目要求第一行放最后一列，第二行放倒数第二列，所以~

本题可以先转置，并按列将每行元素进行翻转。

![image-20230219003338715](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/image-20230219003338715.png)

![image-20230219003319053](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/image-20230219003319053.png)

```java
import java.util.*;

public class Solution {
    public int[][] rotateMatrix(int[][] mat, int n) {
        // write code here
        //先转置：转置实现了将数组逆时针旋转90度，然后上下交换行。
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < i; j++) {
                swap(mat, i, j, j, i);
            }
        }
        //每行进行翻转，即将各列位置互换。
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < (n / 2); j++) {
                swap(mat, i, j, i, n - 1 - j);
            }
        }
        return mat;
    }
    //交换二维数组中两个元素
    public void swap(int[][] matrix, int i, int j, int m, int n) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[m][n];
        matrix[m][n] = temp;
    }
}
```

