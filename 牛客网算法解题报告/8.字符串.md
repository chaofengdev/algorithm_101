## BM83 字符串变形

方法1：双逆转

> 思路：
>
> 1.将字符大写改成小写，小写改成大写
>
> 2.翻转整个字符串
>
> 3.翻转每个单词，以空格为界
>
> 注意事项：
>
> 1.注意StringBuffer的相关api；
>
> 2.注意StringBuffer与String的相互转换；

```java
import java.util.*;

public class Solution {
    public String trans(String s, int n) {
        // write code here
        //1.将字符小写改大写，大写改小写
        StringBuffer res = new StringBuffer();//结果字符串序列
        for(int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if(ch >= 'a' && ch <= 'z') {//ch小写改大写
                res.append((char) (ch - 'a' + 'A'));
            }else if(ch >= 'A' && ch <= 'Z') {//ch大写改小写
                res.append((char)(ch - 'A' + 'a'));
            }else {//ch空格不变
                res.append(ch);
            }
        }
        //System.out.println(res.toString());
        //2.翻转整个字符串
        res.reverse();
        //System.out.println(res.toString());
        //3.翻转单个字符串
        for(int i = 0; i < n; i++) {
            int j = i;
            while(j < n && res.charAt(j) != ' ') {
                j++;
            }
            String temp = res.substring(i,j);//截取待翻转字符串
            StringBuffer buffer = new StringBuffer(temp);
            buffer.reverse();//翻转字符串
            res.replace(i,j,buffer.toString());
            i = j;
        }
        return res.toString();
    }
    
}
```



方法2：分割字符串+栈

```java
import java.util.*;

public class Solution {
    public String trans(String s, int n) {
        // write code here
        //1.将字符小写改大写，大写改小写
        StringBuffer res = new StringBuffer();
        for(int i = 0; i < n; i++) {
            if(s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
                res.append((char)(s.charAt(i) - 'a' + 'A'));
            }else if(s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') {
                res.append((char)(s.charAt(i) - 'A' + 'a'));
            }else if(s.charAt(i) == ' '){
                res.append(" ");
            }
        }
        System.out.println(res.toString());
        //2.分割字符串，进栈
        Stack<String> stack = new Stack<String>();
        for(int i = 0; i < n; i++) {
            int j = i;
            while(j < n && s.charAt(j) != ' ') {
                j++;
            }
            String temp = res.substring(i,j);
            stack.push(temp);
            i = j;
        }
        //特殊情况判断：字符串以空格结尾
        if(s.charAt(n-1) == ' ') {
            res = new StringBuffer(" ");
        }else {
            res = new StringBuffer();
        }
        //3.出栈，拼接字符串
        while(!stack.empty()) {
            res.append(stack.pop());
            if(!stack.empty()) {
                res.append(" ");
            }
        }
        return res.toString();
    }
}
```

## BM84 最长公共前缀

方法1：纵向扫描

> 将字符数组看做二维空间，从第一列开始扫描；
>
> 判断所有字符子串中第一列字符；
>
> 逐层扫描后面每一列字符，遇到不同字符停止扫描。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param strs string字符串一维数组 
     * @return string字符串
     */
    public String longestCommonPrefix (String[] strs) {
        // write code here
        //判空
        if(strs.length == 0 || strs == null) {
            return "";
        }
        //以第一个单词为基准，遍历所有单词的对应字符
        for(int i = 0; i < strs[0].length(); i++) {//i为列号
            char ch = strs[0].charAt(i);
            for(int j = 1; j < strs.length; j++) { //j为行号
                if(strs[j].length() == i || strs[j].charAt(i) != ch) {//注意：如果不对strs[j].length()==i的情况判断，会出现越界异常
                    return strs[0].substring(0,i);
                }
            }
        }
        return strs[0];//第一个单词即为公共前缀
    }
}
```

纵向扫描的其他写法：

```java 
import java.util.*;


public class Solution {
    /**
     * 
     * @param strs string字符串一维数组 
     * @return string字符串
     */
    public String longestCommonPrefix (String[] strs) {
        // write code here
        //判空
        if(strs.length == 0 || strs == null) {
            return "";
        }
        //找到最短的单词并记录长度和位置
        int len = Integer.MAX_VALUE;
        int index = 0;
        for(int i = 0; i < strs.length; i++) {
            if(strs[i].length() < len) {
                len = strs[i].length();
                index = i;
            }
        }
        //System.out.println(len);
        //以第一个单词为基准，遍历所有单词的对应字符
        for(int i = 1; i < strs.length; i++) {//i表示行，从第二行开始
            for(int j = 0; j < len; j++) {//j表示列，从第一列开始，到最短的单词列数
                char ch = strs[0].charAt(j);//不会越界
                char temp = strs[i].charAt(j);//以第一个单词为基准，此处可能越界
                if( ch != temp ) {
                    return strs[0].substring(0,j);
                }
            }
        }
        return strs[index];//没有遇到不一样的字符，则返回长度最小的单词
    }
}
```

纵向扫描的其他写法，同第一种官方解答，只是换了ij的顺序，使得i指行，j指列

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param strs string字符串一维数组 
     * @return string字符串
     */
    public String longestCommonPrefix (String[] strs) {
        // write code here
        //判空
        if(strs.length == 0 || strs == null) {
            return "";
        }
        //以第一个单词为基准，遍历所有单词的对应字符
        for(int j = 0; j < strs[0].length(); j++) {//列号
            for(int i = 1; i < strs.length; i++) {//行号
                if(strs[i].length() == j || strs[i].charAt(j) != strs[0].charAt(j)) {//strs[i].length() == j单词长度不会更多，提前结束判断
                    return strs[0].substring(0,j);
                }
            }
        }
        return strs[0];//返回第一个单词
    }
}
```

方法2：横向扫描

```java

```

