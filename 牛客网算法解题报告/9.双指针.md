## BM87 合并两个有序数组

最容易想到的答案：

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int[] res = new int[m + n];
        int i = 0;
        int j = 0;
        int index = 0;
        while(i < m && j < n) {
            if(A[i] <= B[j]) {
                res[index++] = A[i];
                i++;
            }else {
                res[index++] = B[j];
                j++;
            }
        }
        //处理多余的数
        while(i < m) {
            res[index++] = A[i++];
        }
        while(j < n) {
            res[index++] = B[j++];
        }
        System.out.print(index);
        for(int k = 0; k < index; k++) {
            A[k] = res[k];
        }
    }
}
```

方法1：双指针

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/950C7BF186E017CD92971C19546A49F0)

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int[] res = new int[m + n];
        int i = 0;
        int j = 0;
        int index = 0;
        while(i < m || j < n) {
            if(i == m) {
                res[index++] = B[j++];
            }else if(j == n) {
                res[index++] = A[i++];
            }else if(A[i] <= B[j]) {
                res[index++] = A[i++];
            }else {
                res[index++] = B[j++];
            }
        }
        System.out.print(index);
        for(int k = 0; k < index; k++) {
            A[k] = res[k];
        }
    }
}
```

方法2：合并后排序

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/3E05D5682B2708589E4CEBD52CFE8379)

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        for(int i = 0; i < n; i++) {
            A[m + i] = B[i];
        }
        Arrays.sort(A);
    }
}
```



## BM88 判断是否为回文字符串

最容易想到的答案：

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        StringBuffer s = new StringBuffer(str);
        s.reverse();
        String str2 = s.toString();
        for(int i = 0; i < str.length(); i++) {
            if(str.charAt(i) != str2.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
```

方法1：反转字符比较，同上，但做了一点改进

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        StringBuffer s = new StringBuffer(str);
        String str2 = s.reverse().toString();//反转字符串的更加简洁的写法
        if(str.equals(str2)) {//字符串支持直接比较，不需要比较各字符
            return true;
        }
        return false;
    }
}
```

方法2：双指针

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/A0D8D375C5962864BAE6166CA38789E0)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        int left = 0;
        int right = str.length() - 1;
        while(left < right) {
            if(str.charAt(left++) != str.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}
```



## BM89 合并区间

注：本题和双指针应该没有什么关系，本质上还是模拟合并区间的过程，主要是理清思路。

方法1：排序+贪心

> 贪心：属于动态规划思想中的一种，基本原理是找出整体中局部子结构的最优解，局部最优解结合就是整体上的最优解。
>
> 1.按照区间元素起点排序，若起点相同则按照终点排序；
>
> 2.排序后第一个直接加入结果集合；
>
> 3.若当前元素的起点小于结果集合中最后一个元素的最大值，则合并区间并更新结果集合，即删除原来元素，加入合并区间元素；
>
> 4.若当前元素的起点大于结果集合中最后一个元素的最大值，则将当前元素直接放进结果集合。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/F2925680FFBBBEAF9B4DE9E5A1765F9E)

```java
import java.util.*;
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        ArrayList<Interval> res = new ArrayList<>();
        //特殊情况
        if(intervals.size() == 0) {
            return res;
        }
        //1.集合元素排序
        Collections.sort(intervals,new Comparator<Interval>(){
            public int compare(Interval o1, Interval o2) {
                if(o1.start != o2.start) {//区间首不相等，从小到大排
                    return o1.start - o2.start;
                }else {
                    return o1.end - o2.end;//区间首相等，按区间尾从小到大排
                }
            }
        });
        //2.遍历集合元素，如果前尾小于等于后首则合并，并加入结果集合，否则不合并
        res.add(intervals.get(0));
        for(int i = 0; i < intervals.size(); i++) {
            Interval cur = intervals.get(i);
            Interval temp = res.get(res.size() - 1);//结果集合中最后一个元素
            if(temp.end >= cur.start) {
                Interval in = new Interval(temp.start, cur.end);//新建元素
                res.remove(res.size() - 1);//移除末尾元素
                if(temp.end > cur.end) {//这里需要正确考虑新加入元素的end值
                    in.end = temp.end;
                }
                res.add(in);//添加新元素
            }else {
                res.add(cur);//直接添加当前元素
            }
        }
        return res;
    }
}
```

