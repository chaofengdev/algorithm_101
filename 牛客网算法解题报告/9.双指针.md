## BM87 合并两个有序数组

最容易想到的答案：

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int[] res = new int[m + n];
        int i = 0;
        int j = 0;
        int index = 0;
        while(i < m && j < n) {
            if(A[i] <= B[j]) {
                res[index++] = A[i];
                i++;
            }else {
                res[index++] = B[j];
                j++;
            }
        }
        //处理多余的数
        while(i < m) {
            res[index++] = A[i++];
        }
        while(j < n) {
            res[index++] = B[j++];
        }
        System.out.print(index);
        for(int k = 0; k < index; k++) {
            A[k] = res[k];
        }
    }
}
```

方法1：双指针

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/950C7BF186E017CD92971C19546A49F0)

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int[] res = new int[m + n];
        int i = 0;
        int j = 0;
        int index = 0;
        while(i < m || j < n) {
            if(i == m) {
                res[index++] = B[j++];
            }else if(j == n) {
                res[index++] = A[i++];
            }else if(A[i] <= B[j]) {
                res[index++] = A[i++];
            }else {
                res[index++] = B[j++];
            }
        }
        System.out.print(index);
        for(int k = 0; k < index; k++) {
            A[k] = res[k];
        }
    }
}
```

方法2：合并后排序

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/3E05D5682B2708589E4CEBD52CFE8379)

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        for(int i = 0; i < n; i++) {
            A[m + i] = B[i];
        }
        Arrays.sort(A);
    }
}
```



## BM88 判断是否为回文字符串

最容易想到的答案：

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        StringBuffer s = new StringBuffer(str);
        s.reverse();
        String str2 = s.toString();
        for(int i = 0; i < str.length(); i++) {
            if(str.charAt(i) != str2.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
```

方法1：反转字符比较，同上，但做了一点改进

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        StringBuffer s = new StringBuffer(str);
        String str2 = s.reverse().toString();//反转字符串的更加简洁的写法
        if(str.equals(str2)) {//字符串支持直接比较，不需要比较各字符
            return true;
        }
        return false;
    }
}
```

方法2：双指针

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com/2022/A0D8D375C5962864BAE6166CA38789E0)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        int left = 0;
        int right = str.length() - 1;
        while(left < right) {
            if(str.charAt(left++) != str.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}
```

