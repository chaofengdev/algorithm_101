## BM50 两数之和

```java
//经典leetcode第一题：两数之和
//暴力求解：遍历数组元素，在每个元素后再次遍历找另一个元素，使得两个元素之和为target；
//哈希表：遍历数组元素，每次判断target-numbers[i]是否在哈希表中，如果不在就将该数组元素及对应下标放入哈希表，如果在就直接返回结果；
import java.util.*;
public class Solution {
    /**
     * 
     * @param numbers int整型一维数组 
     * @param target int整型 
     * @return int整型一维数组
     */
    public int[] twoSum (int[] numbers, int target) {
        // write code here
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for(int i = 0; i < numbers.length; i++) {
            if(hashMap.containsKey(target - numbers[i])) {
                return new int[]{hashMap.get(target-numbers[i])+1,i+1};//注意先后次序
            }
            hashMap.put(numbers[i],i);
        }
        return new int[0];
    }
}
```



## BM51 数组中出现次数超一半的数字

```java
//哈希表
//原始解答，初步ac，但存在很多优化的细节
//1.哈希表的使用：map作为统计词频是常用数据结构，它的遍历及添加、删除都有相关api，需要熟练掌握
//2.两次循环：其实只需要一次就够了
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        //哈希表，用来记录元素与次数
        HashMap<Integer,Integer> hashtable = new HashMap<>();
        //遍历数组元素
        for(int i = 0; i < array.length; i++) {
            if(!hashtable.containsKey(array[i])) {//哈希表中没有这个元素
                hashtable.put(array[i],1);
            }else {//哈希表中有这个元素
                hashtable.put(array[i],hashtable.get(array[i])+1);
            }
        }
        //查找哈希表中出现次数大于数组长度一般的数字
        int len = array.length / 2;
        for(int key : hashtable.keySet()) {
            if(hashtable.get(key) > len) {
                return key;
            }
        }
        return -1;
    }
}

//更精炼的解答
//事实上，只需要有一个超过数组长度一半，就可以直接返回，所以不需要第二次遍历
//另外关于map的遍历也需要总结，这里暂时就不写了
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < array.length; i++) {
            map.put(array[i],map.getOrDefault(array[i],0)+1);//代替if...else逻辑
            if(map.get(array[i]) > array.length/2) {//次数超过一数组长度一半
                return array[i];//直接返回
            }
        }
        return 0;
    }
}
```

