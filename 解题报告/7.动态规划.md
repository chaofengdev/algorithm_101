## BM62 斐波那契数列

动态规划的典型题，该题有三种解答方法：

方法1：递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389978-swEaca-image.png)

```java
public class Solution {
    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        return fib(N - 1) + fib(N - 2);
    }
}
```

方法2：递归+缓存/记忆化递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389988-dvJhAs-image.png)

```java
public class Solution {
    int[] memo = new int[41];//备忘录，这里的备忘录也可以写进Fibonacci方法
    public int Fibonacci(int n) {
        //利用状态数组memo保存斐波那契数列的每一项
        // memo[1] = 1;
        // memo[2] = 1;
        return f(n);
    }
    //实际计算斐波那契数列的方法
    public int f(int n) {
        if(n == 1 || n == 2) {
            return 1;
        }
        if(memo[n] == 0) {//这个条件很重要，只有备忘录里没有的才需要计算，已经有的直接返回即可
            memo[n] = f(n - 1) + f(n - 2);//尝试画图理解这个过程，凭空思考往往容易出错
        }
        return memo[n];
    }
}
```

方法3：动态规划

以上两种方法都是【自顶向下】，那么如何实现【自底向上】呢？所谓自底向上即先计算f(n-1)和f(n-2)，再计算f(n)。

如果状态数组命名为dp，表示我们采用【自底向上】递推的方式求解，这是一种习惯。

> 「记忆化递归」实际上也是一种遍历行为，因此也叫「记忆化搜索」。「记忆化递归」更符合人们思考问题的方式：直接面对问题寻找解决方案，并且记录每一步求解的结果，是一种「自顶向下」的思考模式。
>
> 「动态规划」采用了一种很不一样的方式，不直接面对问题求解，而是去发现这个问题最开始的样子，通过一步一步「递推」的方式，最终求得原问题的答案，是一种「自底向上」的思考模式。
>
> 在《算法导论》上，「自顶向下」递归求解与「自底向上」递推求解都称为「动态规划」，我们这个教程为了区分「自顶向下」与「自底向上」，把「自顶向下」递归求解的过程称为「记忆化递归」，而只把「自底向上」递推求解的过程称为「动态规划」。
>
> 作者：liweiwei1419
> 链接：https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/9vi9p7/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
public class Solution {
    public int Fibonacci(int n) {
        //创建状态数组
        int[] dp = new int[n+1];//状态数组
        //实例化状态数组前两个元素
        dp[0] = 0;
        dp[1] = 1;
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

当然还可以进一步优化，我们发现计算f(6)的时候只使用到了f(5)和f(4)，前面f(0)-f(3)都是没有必要保存的，所以只需要3个变量即可。

```java
public class Solution {
    public int Fibonacci(int n) {
        //变量--本质上保存状态
        int a = 0;//f(n - 1)
        int b = 1;//f(n - 2)
        int c = 0;//f(n)，保存f(n-1) + f(n - 2)
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            c = a + b;//递推公式f(n)=f(n-1)+f(n-2)
            a = b;//更新
            b = c;//更新
        }
        return c;//返回f(n)
    }
}
```

## BM63 跳台阶

本质上和BM62斐波那契数列一样。

```java
public class Solution {
    public int jumpFloor(int target) {
        if(target==1){
            return 1;
        }else if(target==2){
            return 2;
        }
        return jumpFloor(target-1)+jumpFloor(target-2);
    }
}
```



## BM64 最小花费爬楼梯

> **知识点：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **思路：**
>
> 题目同样考察斐波那契数列的动态规划实现，不同的是题目要求了最小的花费，因此我们将方案统计进行递推的时候只记录最小的开销方案即可。
>
> **具体做法：**
>
> - step 1：可以用一个数组记录每次爬到第i阶楼梯的最小花费，然后每增加一级台阶就转移一次状态，最终得到结果。
> - step 2：**（初始状态）** 因为可以直接从第0级或是第1级台阶开始，因此这两级的花费都直接为0.
> - step 3：**（状态转移）** 每次到一个台阶，只有两种情况，要么是它前一级台阶向上一步，要么是它前两级的台阶向上两步，因为在前面的台阶花费我们都得到了，因此每次更新最小值即可，转移方程为：dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/CD2B95CDF3D0BEA28A46D1C0172B9F61)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param cost int整型一维数组 
     * @return int整型
     */
    public int minCostClimbingStairs (int[] cost) {
        // write code here
        //状态数组--记录每次爬到第i级楼梯的最小花费
        int[] dp = new int[cost.length+1];
        //初始状态--因为可以直接从0或1级台阶开始，花费都是0
        dp[0] = 0;
        dp[1] = 0;
        //状态转移
        for(int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);//状态转移方程(难点)
        }
        return dp[cost.length];//爬到第i级楼梯的最小花费，即爬到cost数组最后一级楼梯的后一级楼梯的最小花费（理解这题的要求是越过cost数组中下标cost.length-1那级台阶，计算cost.length那级台阶）
    }
}
```

## BM65 最长公共子序列 *

这题是真的难，看了两个多小时，还是没有领会到精髓。

首先附上b站视频，讲的听清晰的：https://www.bilibili.com/video/BV14A411v7mP/

其次附上牛客官方讲解：

> **知识点1：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **知识点2：栈**
>
> 栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
>
> **思路：**
>
> 能够递归解决的也可以用栈解决的，递归实现将问题缩小往前，然后将符合条件的字符依次拼接，栈也可以实现。
>
> **具体做法：**
>
> - step 1：优先检查特殊情况。
> - step 2：获取最长公共子序列的长度可以使用动态规划，我们以dp[i][j]dp[i][j]*d**p*[*i*][*j*]表示在s1中以ii*i*结尾，s2中以jj*j*结尾的字符串的最长公共子序列长度。
> - step 3：遍历两个字符串的所有位置，开始状态转移：若是ii*i*位与jj*j*位的字符相等，则该问题可以变成1+dp[i−1][j−1]1+dp[i-1][j-1]1+*d**p*[*i*−1][*j*−1]，即到此处为止最长公共子序列长度由前面的结果加1。
> - step 4：若是不相等，说明到此处为止的子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，因此我们考虑换成两个子问题，dp[i][j−1]dp[i][j-1]*d**p*[*i*][*j*−1]或者dp[i−1][j]dp[i-1][j]*d**p*[*i*−1][*j*]，我们取较大的一个就可以了。
> - step 5：得到最长长度后，获取不需要第二个辅助数组b，直接从dp数组最后一位开始，每次比较当前位置与其左、上、左上的关系，然后将符合要求的字符加入栈中，符合要求即来自dp表格左上方的字符。
> - step 6：最后将栈中的字符拼接即可得到最长公共子序列，注意检查子序列是否为空。

光看上面的讲解还是有点云里雾里的，附上图像，可以试着填一填，体会一下思路：

![image-20221010232331017](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221010232331017.png)

另外这是牛客网上的图：（说实话，动图往往不太适合理解，很多时候一张静态图片足矣）

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/C8A06E419BA9D0380E76B9F353AC0956)

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        //有空字符串，不会有子序列
        if(s1.length() == 0 || s2.length() == 0) {
            return "-1";
        }
        int len1 = s1.length();
        int len2 = s2.length();
        //状态变量：dp[i][j]表示字符串s1到第i位，字符串s2到第j位，两个子字符串的最长公共子序列的长度
        int[][] dp = new int[len1 + 1][len2 + 1];
        //遍历两个字符串，求每个位置的最长公共子序列长度--即遍历二维数组
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                //状态转移方程
                //两个字符相等
                if(s1.charAt(i-1) == s2.charAt(j-1)) {//charAt(index)中index是从0开始的
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //来自上方后者左边的最大值--理解一下为什么取最大值，因为求的是最大公共子序列的长度
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        // for(int i = 1; i <= len1; i++) {
        //     for(int j = 1; j <= len2; j++) {
        //         System.out.print(dp[i][j]+",");
        //     }
        // }
        //动态规划数组已经计算完毕
        //下面是求具体最长公共子序列
        int i = len1;
        int j = len2;
        Stack<Character> stack = new Stack<>();
        while(dp[i][j] != 0) {//退出条件
            if(dp[i][j] == dp[i-1][j]) {
                i--;
            }else if(dp[i][j]==dp[i][j-1]) {
                j--;
            }else if(dp[i][j] > dp[i-1][j-1]) {
                i--;
                j--;
                stack.push(s1.charAt(i));//当然这里也可以s2.charAt(j)
            }
        }
        String res = "";//空字符串
        while(!stack.isEmpty()) {
            res += stack.pop();
        }
        //如果没有公共子序列，需要返回-1，这里需要处理一下
        return res.isEmpty() ? "-1" : res;
    }
}
```

