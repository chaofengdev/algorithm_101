## BM62 斐波那契数列

动态规划的典型题，该题有三种解答方法：

方法1：递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389978-swEaca-image.png)

```java
public class Solution {
    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        return fib(N - 1) + fib(N - 2);
    }
}
```

方法2：递归+缓存/记忆化递归

![image.png](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/1604389988-dvJhAs-image.png)

```java
public class Solution {
    int[] memo = new int[41];//备忘录，这里的备忘录也可以写进Fibonacci方法
    public int Fibonacci(int n) {
        //利用状态数组memo保存斐波那契数列的每一项
        // memo[1] = 1;
        // memo[2] = 1;
        return f(n);
    }
    //实际计算斐波那契数列的方法
    public int f(int n) {
        if(n == 1 || n == 2) {
            return 1;
        }
        if(memo[n] == 0) {//这个条件很重要，只有备忘录里没有的才需要计算，已经有的直接返回即可
            memo[n] = f(n - 1) + f(n - 2);//尝试画图理解这个过程，凭空思考往往容易出错
        }
        return memo[n];
    }
}
```

方法3：动态规划

以上两种方法都是【自顶向下】，那么如何实现【自底向上】呢？所谓自底向上即先计算f(n-1)和f(n-2)，再计算f(n)。

如果状态数组命名为dp，表示我们采用【自底向上】递推的方式求解，这是一种习惯。

> 「记忆化递归」实际上也是一种遍历行为，因此也叫「记忆化搜索」。「记忆化递归」更符合人们思考问题的方式：直接面对问题寻找解决方案，并且记录每一步求解的结果，是一种「自顶向下」的思考模式。
>
> 「动态规划」采用了一种很不一样的方式，不直接面对问题求解，而是去发现这个问题最开始的样子，通过一步一步「递推」的方式，最终求得原问题的答案，是一种「自底向上」的思考模式。
>
> 在《算法导论》上，「自顶向下」递归求解与「自底向上」递推求解都称为「动态规划」，我们这个教程为了区分「自顶向下」与「自底向上」，把「自顶向下」递归求解的过程称为「记忆化递归」，而只把「自底向上」递推求解的过程称为「动态规划」。
>
> 作者：liweiwei1419
> 链接：https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/9vi9p7/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
public class Solution {
    public int Fibonacci(int n) {
        //创建状态数组
        int[] dp = new int[n+1];//状态数组
        //实例化状态数组前两个元素
        dp[0] = 0;
        dp[1] = 1;
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

当然还可以进一步优化，我们发现计算f(6)的时候只使用到了f(5)和f(4)，前面f(0)-f(3)都是没有必要保存的，所以只需要3个变量即可。

```java
public class Solution {
    public int Fibonacci(int n) {
        //变量--本质上保存状态
        int a = 0;//f(n - 1)
        int b = 1;//f(n - 2)
        int c = 0;//f(n)，保存f(n-1) + f(n - 2)
        //自底向上递推
        for(int i = 2; i < n + 1; i++) {//这里从2开始
            c = a + b;//递推公式f(n)=f(n-1)+f(n-2)
            a = b;//更新
            b = c;//更新
        }
        return c;//返回f(n)
    }
}
```

## BM63 跳台阶

本质上和BM62斐波那契数列一样。

```java
public class Solution {
    public int jumpFloor(int target) {
        if(target==1){
            return 1;
        }else if(target==2){
            return 2;
        }
        return jumpFloor(target-1)+jumpFloor(target-2);
    }
}
```



## BM64 最小花费爬楼梯

> **知识点：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **思路：**
>
> 题目同样考察斐波那契数列的动态规划实现，不同的是题目要求了最小的花费，因此我们将方案统计进行递推的时候只记录最小的开销方案即可。
>
> **具体做法：**
>
> - step 1：可以用一个数组记录每次爬到第i阶楼梯的最小花费，然后每增加一级台阶就转移一次状态，最终得到结果。
> - step 2：**（初始状态）** 因为可以直接从第0级或是第1级台阶开始，因此这两级的花费都直接为0.
> - step 3：**（状态转移）** 每次到一个台阶，只有两种情况，要么是它前一级台阶向上一步，要么是它前两级的台阶向上两步，因为在前面的台阶花费我们都得到了，因此每次更新最小值即可，转移方程为：dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/CD2B95CDF3D0BEA28A46D1C0172B9F61)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param cost int整型一维数组 
     * @return int整型
     */
    public int minCostClimbingStairs (int[] cost) {
        // write code here
        //状态数组--记录每次爬到第i级楼梯的最小花费
        int[] dp = new int[cost.length+1];
        //初始状态--因为可以直接从0或1级台阶开始，花费都是0
        dp[0] = 0;
        dp[1] = 0;
        //状态转移
        for(int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);//状态转移方程(难点)
        }
        return dp[cost.length];//爬到第i级楼梯的最小花费，即爬到cost数组最后一级楼梯的后一级楼梯的最小花费（理解这题的要求是越过cost数组中下标cost.length-1那级台阶，计算cost.length那级台阶）
    }
}
```

## BM65 最长公共子序列 *

这题是真的难，看了两个多小时，还是没有领会到精髓。

首先附上b站视频，讲的听清晰的：https://www.bilibili.com/video/BV14A411v7mP/

其次附上牛客官方讲解：--有些地方格式错误，懒得修改了，后面复习的时候修改吧。

> **知识点1：动态规划**
>
> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果
>
> **知识点2：栈**
>
> 栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
>
> **思路：**
>
> 能够递归解决的也可以用栈解决的，递归实现将问题缩小往前，然后将符合条件的字符依次拼接，栈也可以实现。
>
> **具体做法：**
>
> - step 1：优先检查特殊情况。
> - step 2：获取最长公共子序列的长度可以使用动态规划，我们以dp[i][j]dp[i][j]*d**p*[*i*][*j*]表示在s1中以ii*i*结尾，s2中以jj*j*结尾的字符串的最长公共子序列长度。
> - step 3：遍历两个字符串的所有位置，开始状态转移：若是ii*i*位与jj*j*位的字符相等，则该问题可以变成`1+dp[i−1][j−1]1+dp[i-1][j-1]1+*d**p*[*i*−1][*j*−1]`，即到此处为止最长公共子序列长度由前面的结果加1。
> - step 4：若是不相等，说明到此处为止的子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，因此我们考虑换成两个子问题，`dp[i][j−1]dp[i][j-1]*d**p*[*i*][*j*−1]或者dp[i−1][j]dp[i-1][j]*d**p*[*i*−1][*j*]`，我们取较大的一个就可以了。
> - step 5：得到最长长度后，获取不需要第二个辅助数组b，直接从dp数组最后一位开始，每次比较当前位置与其左、上、左上的关系，然后将符合要求的字符加入栈中，符合要求即来自dp表格左上方的字符。
> - step 6：最后将栈中的字符拼接即可得到最长公共子序列，注意检查子序列是否为空。

光看上面的讲解还是有点云里雾里的，附上图像，可以试着填一填，体会一下思路：

![image-20221010232331017](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221010232331017.png)

另外这是牛客网上的图：（说实话，动图往往不太适合理解，很多时候一张静态图片足矣）

![图片说明](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/C8A06E419BA9D0380E76B9F353AC0956)

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        //有空字符串，不会有子序列
        if(s1.length() == 0 || s2.length() == 0) {
            return "-1";
        }
        int len1 = s1.length();
        int len2 = s2.length();
        //状态变量：dp[i][j]表示字符串s1到第i位，字符串s2到第j位，两个子字符串的最长公共子序列的长度
        int[][] dp = new int[len1 + 1][len2 + 1];
        //遍历两个字符串，求每个位置的最长公共子序列长度--即遍历二维数组
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                //状态转移方程
                //两个字符相等
                if(s1.charAt(i-1) == s2.charAt(j-1)) {//charAt(index)中index是从0开始的
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //来自上方后者左边的最大值--理解一下为什么取最大值，因为求的是最大公共子序列的长度
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        // for(int i = 1; i <= len1; i++) {
        //     for(int j = 1; j <= len2; j++) {
        //         System.out.print(dp[i][j]+",");
        //     }
        // }
        //动态规划数组已经计算完毕
        //下面是求具体最长公共子序列
        int i = len1;
        int j = len2;
        Stack<Character> stack = new Stack<>();
        while(dp[i][j] != 0) {//退出条件
            if(dp[i][j] == dp[i-1][j]) {
                i--;
            }else if(dp[i][j]==dp[i][j-1]) {
                j--;
            }else if(dp[i][j] > dp[i-1][j-1]) {
                i--;
                j--;
                stack.push(s1.charAt(i));//当然这里也可以s2.charAt(j)
            }
        }
        String res = "";//空字符串
        while(!stack.isEmpty()) {
            res += stack.pop();
        }
        //如果没有公共子序列，需要返回-1，这里需要处理一下
        return res.isEmpty() ? "-1" : res;
    }
}
```

## BM66 最长公共子串 *

其实这题和BM65相似，比最长公共子序列更简单一些，因为公共子序列需要考虑字符的拼接问题，而子串只需要从原字符串截取即可。

同样附上B站讲解：https://www.bilibili.com/video/BV1aK411J7b8/

![image-20221011010100402](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221011010100402.png)

牛客官方解答：这题没有给出图像，有点遗憾，虽然和上面没什么区别就是了。

> 注意这题求的是最长公共子串，不是最长公共子序列，子序列可以是不连续的，但子串一定是连续的。
>
> 定义dp[i][j]表示字符串str1中第i个字符和str2种第j个字符为最后一个元素所构成的最长公共子串。如果要求dp[i][j]，也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串，我们首先需要判断这两个字符是否相等。
>
> - 如果不相等，那么他们就不能构成公共子串，也就是
>   **dp[i][j]=0;**
> - 如果相等，我们还需要计算前面相等字符的个数，其实就是dp[i-1][j-1]，所以
>   **dp[i][j]=dp[i-1][j-1]+1**;
>
> 有了递推公式，代码就比较简单了，我们使用两个变量，一个记录最长的公共子串，一个记录最长公共子串的结束位置，最后再对字符串进行截取即可.

```java
import java.util.*;


public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String str1, String str2) {
        // write code here
        //记录最长公共子串substring的长度
        int maxLen = 0;
        //记录最长公共子串最后一个元素在字符串str1中的位置
        int maxLastIndex = 0;
        //辅助变量
        int len1 = str1.length();
        int len2 = str2.length();
        //状态变量：以第i个字符结尾的str1的子串和以第j个字符结尾的str2的子串，包含最后两个元素的两个子串的最长公共子串的长度--也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串（明确状态变量）
        int[][] dp = new int[len1+1][len2+1];
        //遍历数组，通过状态转移方程求出最长公共子串的长度和最长公共子串的最后一个元素的位置
        for(int i = 0; i < len1; i++) {
            for(int j = 0; j < len2; j++) {
                //两个字符相等
                if(str1.charAt(i) == str2.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;//注意这里的下标，不要搞错
                    if(dp[i+1][j+1] > maxLen) {
                        maxLen = dp[i+1][j+1];
                        maxLastIndex = i;//这里记录的是在str中的位置
                    }
                }else {//两个字符不等
                    dp[i + 1][j + 1] = 0;
                }
            }
        }
        //截取原字符串得到结果
        System.out.println(maxLen - maxLastIndex + 1);
        System.out.println(maxLastIndex + 1);
        return str1.substring(maxLastIndex - maxLen + 1, maxLastIndex + 1);//注意这里是左闭右开区间
    }
}
```

## BM67 不同路径的数目

![image-20221012095805826](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221012095805826.png)

起点到终点有多少条路径呢？（只能从起点开始，向下或者向右走，直到终点）

方法一：递归

> **思路：**
>
> 首先我们在左上角第一个格子的时候，有两种行走方式：如果向右走，相当于后面在一个(n−1)∗m的矩阵中查找从左上角到右下角的不同路径数；而如果向下走，相当于后面在一个n∗(m−1)的矩阵中查找从左上角到右下角不同的路径数。而(n−1)∗m的矩阵与n∗(m−1)的矩阵都是n∗m矩阵的子问题，因此可以使用递归。
>
> **具体做法：**
>
> - step 1：**（终止条件）** 当矩阵变长n减少到1的时候，很明显只能往下走，没有别的选择了，只有1条路径；同理m减少到1时也是如此。因此此时返回数量为1.
> - step 2：**（返回值）** 对于每一级都将其两个子问题返回的结果相加返回给上一级。
> - step 3：**（本级任务）** 每一级都有向下或者向右两种路径选择，分别进入相应分支的子问题。

```java
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param m int整型 
 * @param n int整型 
 * @return int整型
 */
int uniquePaths(int m, int n ) {
    // write code here
    if(m == 1 || n == 1) {//此时路径数只有1
        return 1;
    }
    int num = uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
    return num;
}
```

方法二：动态规划

> **思路：**
>
> 如果我们此时就在右下角的格子，那么能够到达该格子的路径只能是它的上方和它的左方两个格子，因此从左上角到右下角的路径数应该是从左上角到它的左边格子和上边格子的路径数之和，因此可以动态规划。
>
> **具体做法：**
>
> - step 1：用`dp[i][j]`表示大小为i∗j的矩阵的路径数量，下标从1开始。
> - step 2：**（初始条件）** 当i或者j为1的时候，代表矩阵只有一行或者一列，因此只有一种路径。
> - step 3：**（转移方程）** 每个格子的路径数只会来自它左边的格子数和上边的格子数，因此状态转移为`dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`。

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/59CA06CDCAD5CEBE36459528F0B24D23)

```java
import java.util.*;


public class Solution {
    /**
     *
     * @param m int整型
     * @param n int整型
     * @return int整型
     */
    public int uniquePaths (int m, int n) {
        // write code here
        //定义状态变量dp[i][j]，表示长宽ij的矩阵的路径长度
        int[][] dp = new int[m + 1][n + 1];
        //状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1) { //i=1时，显然只能向右走，只有一种路径
                    dp[i][j] = 1;
                    continue;
                }
                if (j == 1) { //j=1时，显然只能向下走，只有一种路径
                    dp[i][j] = 1;
                    continue;
                }
                //状态转移方程，表示位置[i,j]路径数等于[i-1,j][i,j-1]的路径和
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
```

## BM68 矩阵的最小路径和

求左上到右下的路径和，如图所示：

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/06EB123C153852AF55ED51448BEAD1BA)

方法一：动态规划

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/47BEDBEA9F525B5752D6DB1BE8B0C928)

> **思路：**
>
> 最朴素的解法莫过于枚举所有的路径，然后求和，找出其中最大值。但是像这种有状态值可以转移的问题，我们可以尝试用**动态规划**。
>
> **具体做法：**
>
> - step 1：我们可以构造一个与矩阵同样大小的二维辅助数组，其中`dp[i][j]`表示以[i,j]位置为终点的最短路径和，则`dp[0][0]=matrix[0][0]`。
> - step 2：很容易知道第一行与第一列，只能分别向右或向下，没有第二种选择，因此第一行只能由其左边的累加，第一列只能由其上面的累加。
> - step 3：边缘状态构造好以后，遍历矩阵，补全矩阵中每个位置的dp数组值：如果当前的位置是[i,j]，上一步要么是[i-1,j]往下，要么就是[i,j-1]往右，那么取其中较小值与当前位置的值相加就是到当前位置的最小路径和，因此状态转移公式为`dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + matrix[i][j]`。
> - step 4：最后移动到[m-1,n-1]的位置就是到右下角的最短路径和。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        //状态变量：dp[i][j]表示到达位置[i,j]的最小路径和
        int row = matrix.length;
        int col = matrix[0].length;
        int[][] dp = new int[row][col];
        //dp[i][j]的初始化
        dp[0][0] = matrix[0][0];
        for(int i = 1; i < row; i++) {//第一列，注意这里i从1开始
            dp[i][0] = matrix[i][0] + dp[i - 1][0];
        }
        for(int j = 1 ; j < col; j++) {//第一行
            dp[0][j] = matrix[0][j] + dp[0][j - 1];
        }
        //状态转移
        for(int i = 1; i < row; i++) {
            for(int j = 1; j < col; j++) {
                if(dp[i][j-1] < dp[i-1][j]) {//状态转移方程
                    dp[i][j] = matrix[i][j] + dp[i][j-1];
                }else {
                    dp[i][j] = matrix[i][j] + dp[i-1][j];
                }
            }
        }
        return dp[row - 1][col - 1];
    }
}
```

方法一改进：动态规划

> 原数组matrix和状态数组dp的长宽一样，考虑使用matrix代替dp，但是这样会更改原来的matrix数组

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        //状态变量：dp[i][j]表示到达位置[i,j]的最小路径和
        int row = matrix.length;
        int col = matrix[0].length;
        //状态转移
        for(int i = 0; i < row; i++) {
            for(int j = 0; j < col; j++) {
                if(i == 0 && j == 0) {
                    continue;
                }
                if(i == 0) {
                    matrix[i][j] += matrix[i][j - 1];
                }else if(j == 0) {
                    matrix[i][j] += matrix[i - 1][j];
                }else {
                    matrix[i][j] += Math.min(matrix[i-1][j],matrix[i][j-1]);
                }
            }
        }
        return matrix[row - 1][col - 1];
    }
}
```

方法三：递归--有点困，暂略。需要用特定数据结构保存中间结果，不然会超时。二刷研究研究吧。

递归方法，明确递归函数定义：从[0,0]到[i,j]的最小路径长度；

根据递归三段式，可写出递归的代码，但是此时代码会超时，为什么呢？

显然中间进行大量的重复运算，我们采用map集合保存中间结果，如果有res，直接取出并返回，如果没有res，将其保存到map集合。

代码如下：--这里本质上和斐波那契数列一样，同样可以选择递归或者更优的动态规划，且动态规划的状态数组可以简化。

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    HashMap<String,Integer> map = new HashMap<>();
    public int minPathSum (int[][] matrix) {
        // write code here
        int row = matrix.length;
        int col = matrix[0].length;
        return recursion(matrix,row-1,col-1);
    }
    //递归，函数recursion(...)表示计算左上角到[i,j]的最短路径和
    public int recursion(int[][]matrix, int i, int j) {
        //递归出口
        if(i == 0 && j == 0) {
            return matrix[0][0];
        }
        int res = 0;//保存最短路径和的结果
        //如果有直接从map中取--解决超时问题
        String key = i + "*" + j;
        if(map.containsKey(key)) {
            return map.get(key);
        }
        if(i == 0) {
            res = matrix[i][j] + recursion(matrix,i,j-1);
        }else if(j == 0) {
            res = matrix[i][j] + recursion(matrix,i-1,j);
        }else {
            res = matrix[i][j] + Math.min(recursion(matrix,i,j-1),recursion(matrix,i-1,j));
        }
        map.put(key,res);//将计算过的值放入到map中--解决超时问题
        return res;
    }
}
```

## BM69 把数字翻译成字符串

> **思路：**
>
> 对于普通数组1-9，译码方式只有一种，但是对于11-19，21-26，译码方式有可选择的两种方案，因此我们使用动态规划将两种方案累计。
>
> **具体做法：**
>
> - step 1：用辅助数组dp表示前i个数的译码方法有多少种。
> - step 2：对于一个数，我们可以直接译码它，也可以将其与前面的1或者2组合起来译码：如果直接译码，则dp[i]=dp[i−1];如果组合译码，则dp[i]=dp[i−2]。
> - step 3：对于只有一种译码方式的，选上种dp[i−1]即可，对于满足两种译码方式（10，20不能）则是dp[i−1]+dp[i−2]
> - step 4：依次相加，最后的dp[length]即为所求答案。

这题牛客的解答不是很好，更简单易懂的解答：

https://www.bilibili.com/video/BV1K341117Pm/ 

解答中与BM69不同的是，leetcode是0-25表示a-z，这样0与其他数字的地位相同，而BM69这题，1-26表示a-z，这样0的地位就不同了，体现在“0”本身不能翻译，但是“10”“20”可以翻译，同时“100”“200”之类的不能翻译。所以需要特殊处理。

如图：

![image-20221013122132483](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221013122132483.png)

当然如果选择int[] dp = new int[len+1];，则采用下面的图示：--后来我想了想，貌似没有本质区别，都是先初始化`dp[0]、dp[1]`。

![img](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/46d1fbb9a5943ddc56a48fa52d90447f4cf19467d67e6a44ae9b04dbc9804841-Picture10.png)

```java
import java.util.*;


public class Solution {
    /**
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    public int solve (String nums) {
        // write code here
        int len = nums.length();
        //dp数组：表示前i位可以解码的总数
        int[] dp = new int[len];
        dp[0] = 1;//显然只有1种翻译情况
        //特例判断--针对特定测试用例
        if(nums.equals("0")) return 0;//"0"结果为0
        for(int i = 1; i < len; i++) {//"100"结果为0--当0前面不是1或2时，无法译码（本题难点）
            if(nums.charAt(i) == '0') {
                if(nums.charAt(i-1) != '1' && nums.charAt(i-1) != '2') {
                    return 0;
                }
            }
        }
        //状态转移
        for(int i = 1; i < len; i++) {
            if(nums.charAt(i-1) == '1' && nums.charAt(i) != '0' 
            || nums.charAt(i-1) == '2' && nums.charAt(i) <= '6' && nums.charAt(i) > '0') {//只有这两种情况满足dp[i] = dp[i-1][i-2] 注意，这里需要考虑 10 20的特殊情况
                if(i == 1) {//i==1特殊考虑
                    dp[i] = 2;
                }else {//状态转移方程
                    dp[i] = dp[i-1] + dp[i-2];
                }
            }else {//状态转移方程
                dp[i] = dp[i-1];//官方答案在这里出错，这里代码也是错的，比如“120”，代码输出2，其实是1
            }
        }
        //返回
        return dp[len-1];
    }
}
```

这题写的有点乱，仔细想想还是1.定义状态参数；2.初始化部分状态参数；3.状态转移填满状态数组；4.从状态数组中得到结果。

这题官方答案也有问题，推荐还是看leetcode上的数字翻译，同时后面也研究下为啥每次状态数组长度都定义成len+1

## BM70 兑换零钱

方法一：动态规划

该方法没有找到非常好的图，这个图已经很详细了。来自b站：https://www.bilibili.com/video/BV13f4y1e7vL/

![image-20221013173344345](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/image-20221013173344345.png)

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // write code here
        //状态数组：dp[i]表示凑成面值i所需要的最小零钱数目
        int[] dp = new int[aim+1];
        //状态初始化
        Arrays.fill(dp,aim+1);
        dp[0] = 0;
        //状态转移--填数组的过程
        for(int i = 1; i < dp.length; i++) {
            for(int j = 0; j < arr.length; j++) {
                if(i >= arr[j]) {//注意：目标面值需要大于等于零钱
                    dp[i] = Math.min(dp[i], dp[i-arr[j]] + 1);//状态转移方程dp[i]=min(dp[i-arr[j]]+1)
                }
            }
        }
        return dp[aim] == aim + 1 ? -1 : dp[aim];
    }
}
```

方法二：记忆化搜索

![alt](https://typora-1256823886.cos.ap-nanjing.myqcloud.com//2021/C717E3CAF4B26554221532DD4BC6BB1E)

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // write code here
        int[] dp = new int[aim + 1];//记录中间变量，记忆化递归
        return recursion(arr,aim,dp);//返回需要的零钱数量
    }
    //返回：需要的零钱数目
    //参数：arr:零钱数组 aim:当前面值 dp:保存面值i需要的最少零钱数
    public int recursion(int[] arr, int aim, int[] dp) {
        //递归出口
        //当前面值为0需要的零钱数
        if(aim == 0) {
            return 0;//正好凑出面值
        }
        //当前面值为负需要的零钱数
        if(aim < 0) {
            return -1;//无法凑出面值
        }
        //直接查找数组，是否已经计算过
        if(dp[aim] != 0) {
            return dp[aim];
        }
        //当前任务
        //遍历零钱
        int min = aim;//记录最小的零钱数
        for(int i = 0; i < arr.length; i++) {
            int res = recursion(arr,aim - arr[i],dp);//计算子过程需要的最小零钱数
            if(res >= 0) {//排除res==-1的情况
                min = Math.min(min,res+1);//更新最小零钱数目
            }  
        }
        //更新记忆数组
        dp[aim] = (min == aim) ? -1 : min;
        return dp[aim];
    }
}
```

