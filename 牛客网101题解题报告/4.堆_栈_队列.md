## BM42 用两个栈实现队列

```java
//双栈法--实际上题目已经写好了两个栈，方法已经明确
//以下为我写的版本：
//队列offer操作：元素进stack1即可
//队列poll操作：如果stack2非空，从stack2中弹出元素；如果stack2为空，将stack1中的元素放入stack2中，然后从stack2中弹出元素。
//官方解答：
//队列offer操作：同样元素进stack1即可
//队列poll操作：stack1元素全部放入stack2，从stack2中弹出元素，将stack2元素放回stack1
//可以看到官方的解答多了一次放回的操作。
//另外本题没有考虑异常情况，因为题目中说了“保证操作合法，即保证pop操作时队列内已有元素。”
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(!stack2.isEmpty()) {//stack2不为空
            return stack2.pop();
        }else {//栈2为空
            while(!stack1.isEmpty()) {//将stack1元素全部放进stack2
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
        //return stack2.pop();
    }
}

//当前写法可以更简洁一些，本质是一样的。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        //元素统一放进栈A
        stack1.push(node);
    }

    public int pop() {
        //栈B为空，将栈A元素放进栈B
        if(stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        //返回栈B的栈顶元素
        return stack2.pop();
    }
}
```

## BM43 包含min函数的栈

```java
//双栈法--和官解有点写法上的不同，本质一样
//核心思路：用minStack保存从栈底到当前结点的最小值，即minStack栈顶都是当前栈stack的最小值。
import java.util.Stack;

public class Solution {
    //以下为辅助数据结构
    Stack<Integer> stack = new Stack<>();//存放正常结点，维持栈结构
    Stack<Integer> minStack = new Stack<>();//存放从栈底到当前结点的最小值，实现最小栈功能
    
    public void push(int node) {
        stack.push(node);
        if(minStack.isEmpty()) {//minStack为空，没有栈顶元素，需要特殊判断一下
            minStack.push(node);
        }else {//minStack不为空
            //栈顶元素
            int temp = minStack.peek();
            //新加的元素小于栈顶元素，则新元素入栈，否则栈顶元素再次入栈
            minStack.push(node < temp ? node : temp);
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

## BM44 有效括号序列

```java
//自己写的解答，只是能ac，感觉挺烂的。
//基本思路：将符号分为左符号和右符号，左符号包括({[，右符号包括)}]。使用一个辅助栈，遍历字符串转换后的字符串数组，每次遇到一个左符号就进栈，遇到一个右符号就查看是否栈顶符号匹配，如果匹配就出栈并继续遍历，不匹配直接返回false。最后要注意stack是否为空，如果不为空，说明还有几个左符号留在了栈里没有匹配。
import java.util.*;

public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        // write code here
        Stack<String> stack = new Stack<>();//辅助栈
        String[] strArr = s.split("");//字符串转字符串数组，方便处理单个字符串
        for(int i = 0; i < strArr.length; i++) {
            String str = strArr[i];
            if(str.equals("(") || str.equals("{") || str.equals("[")) {//左符号进栈
                stack.push(str);
            }
            if(str.equals(")") || str.equals("}") || str.equals("]")) {//右符号进行匹配（这句是多余判断，可以去掉）
                String temp = null;
                if(!stack.isEmpty()) {
                    temp = stack.pop();
                }else {
                    return false;//不匹配
                }
                if(str.equals(")") && temp.equals("(")) {
                    continue;
                }
                if(str.equals("}") && temp.equals("{")) {
                    continue;
                }
                if(str.equals("]") && temp.equals("[")) {
                    continue;
                }
                return false;//不匹配
            }
        }
        if(!stack.isEmpty()) {
            return false;//栈里还有一些左符号
        }
        return true;
    }
}

//官方解答--写法很巧妙，值得借鉴
//主要的优化有两点：1.辅助栈只入右符号，这样匹配就变成了判断栈顶元素是否与遍历到的元素相等；2.其他细节如直接使用字符比较。
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        // write code here
        Stack<Character> stack = new Stack<>();//辅助栈存放字符
        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);//遍历到的字符
            //如果是左符号，添加对应的右符号
            if(ch == '(') {//字符ch是基本数据类型，可以直接用==判断是否相等
                stack.push(')');
            }else if(ch == '[') {
                stack.push(']');
            }else if(ch == '{') {
                stack.push('}');
            //如果栈空，说明刚开始的是右符号，直接返回false
            //如果遍历到的字符与栈顶不相等，说明不匹配，同样返回false
            //另一种理解思路：必须有左符号才能匹配右符号
            }else if(stack.isEmpty() || ch != stack.pop()) {
                return false;
            }
        }
        return stack.isEmpty();//判断栈是否为空，不为空说明有左符号
    }
}
```

## BM45 滑动窗口的最大值

```java

```

