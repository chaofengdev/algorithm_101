## BM42 用两个栈实现队列

```java
//双栈法--实际上题目已经写好了两个栈，方法已经明确
//以下为我写的版本：
//队列offer操作：元素进stack1即可
//队列poll操作：如果stack2非空，从stack2中弹出元素；如果stack2为空，将stack1中的元素放入stack2中，然后从stack2中弹出元素。
//官方解答：
//队列offer操作：同样元素进stack1即可
//队列poll操作：stack1元素全部放入stack2，从stack2中弹出元素，将stack2元素放回stack1
//可以看到官方的解答多了一次放回的操作。
//另外本题没有考虑异常情况，因为题目中说了“保证操作合法，即保证pop操作时队列内已有元素。”
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(!stack2.isEmpty()) {//stack2不为空
            return stack2.pop();
        }else {//栈2为空
            while(!stack1.isEmpty()) {//将stack1元素全部放进stack2
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
        //return stack2.pop();
    }
}

//当前写法可以更简洁一些，本质是一样的。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        //元素统一放进栈A
        stack1.push(node);
    }

    public int pop() {
        //栈B为空，将栈A元素放进栈B
        if(stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        //返回栈B的栈顶元素
        return stack2.pop();
    }
}
```

## BM43 包含min函数的栈

```java
//双栈法--和官解有点写法上的不同，本质一样
//核心思路：用minStack保存从栈底到当前结点的最小值，即minStack栈顶都是当前栈stack的最小值。
import java.util.Stack;

public class Solution {
    //以下为辅助数据结构
    Stack<Integer> stack = new Stack<>();//存放正常结点，维持栈结构
    Stack<Integer> minStack = new Stack<>();//存放从栈底到当前结点的最小值，实现最小栈功能
    
    public void push(int node) {
        stack.push(node);
        if(minStack.isEmpty()) {//minStack为空，没有栈顶元素，需要特殊判断一下
            minStack.push(node);
        }else {//minStack不为空
            //栈顶元素
            int temp = minStack.peek();
            //新加的元素小于栈顶元素，则新元素入栈，否则栈顶元素再次入栈
            minStack.push(node < temp ? node : temp);
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

