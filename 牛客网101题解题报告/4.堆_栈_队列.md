## BM42 用两个栈实现队列

```java
//双栈法--实际上题目已经写好了两个栈，方法已经明确
//以下为我写的版本：
//队列offer操作：元素进stack1即可
//队列poll操作：如果stack2非空，从stack2中弹出元素；如果stack2为空，将stack1中的元素放入stack2中，然后从stack2中弹出元素。
//官方解答：
//队列offer操作：同样元素进stack1即可
//队列poll操作：stack1元素全部放入stack2，从stack2中弹出元素，将stack2元素放回stack1
//可以看到官方的解答多了一次放回的操作。
//另外本题没有考虑异常情况，因为题目中说了“保证操作合法，即保证pop操作时队列内已有元素。”
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(!stack2.isEmpty()) {//stack2不为空
            return stack2.pop();
        }else {//栈2为空
            while(!stack1.isEmpty()) {//将stack1元素全部放进stack2
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
        //return stack2.pop();
    }
}

//当前写法可以更简洁一些，本质是一样的。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//负责push
    Stack<Integer> stack2 = new Stack<Integer>();//负责poo

    public void push(int node) {
        //元素统一放进栈A
        stack1.push(node);
    }

    public int pop() {
        //栈B为空，将栈A元素放进栈B
        if(stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        //返回栈B的栈顶元素
        return stack2.pop();
    }
}
```

## BM43 包含min函数的栈

```java
//双栈法--和官解有点写法上的不同，本质一样
//核心思路：用minStack保存从栈底到当前结点的最小值，即minStack栈顶都是当前栈stack的最小值。
import java.util.Stack;

public class Solution {
    //以下为辅助数据结构
    Stack<Integer> stack = new Stack<>();//存放正常结点，维持栈结构
    Stack<Integer> minStack = new Stack<>();//存放从栈底到当前结点的最小值，实现最小栈功能
    
    public void push(int node) {
        stack.push(node);
        if(minStack.isEmpty()) {//minStack为空，没有栈顶元素，需要特殊判断一下
            minStack.push(node);
        }else {//minStack不为空
            //栈顶元素
            int temp = minStack.peek();
            //新加的元素小于栈顶元素，则新元素入栈，否则栈顶元素再次入栈
            minStack.push(node < temp ? node : temp);
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

## BM44 有效括号序列

```java
//自己写的解答，只是能ac，感觉挺烂的。
//基本思路：将符号分为左符号和右符号，左符号包括({[，右符号包括)}]。使用一个辅助栈，遍历字符串转换后的字符串数组，每次遇到一个左符号就进栈，遇到一个右符号就查看是否栈顶符号匹配，如果匹配就出栈并继续遍历，不匹配直接返回false。最后要注意stack是否为空，如果不为空，说明还有几个左符号留在了栈里没有匹配。
import java.util.*;

public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        // write code here
        Stack<String> stack = new Stack<>();//辅助栈
        String[] strArr = s.split("");//字符串转字符串数组，方便处理单个字符串
        for(int i = 0; i < strArr.length; i++) {
            String str = strArr[i];
            if(str.equals("(") || str.equals("{") || str.equals("[")) {//左符号进栈
                stack.push(str);
            }
            if(str.equals(")") || str.equals("}") || str.equals("]")) {//右符号进行匹配（这句是多余判断，可以去掉）
                String temp = null;
                if(!stack.isEmpty()) {
                    temp = stack.pop();
                }else {
                    return false;//不匹配
                }
                if(str.equals(")") && temp.equals("(")) {
                    continue;
                }
                if(str.equals("}") && temp.equals("{")) {
                    continue;
                }
                if(str.equals("]") && temp.equals("[")) {
                    continue;
                }
                return false;//不匹配
            }
        }
        if(!stack.isEmpty()) {
            return false;//栈里还有一些左符号
        }
        return true;
    }
}

//官方解答--写法很巧妙，值得借鉴
//主要的优化有两点：1.辅助栈只入右符号，这样匹配就变成了判断栈顶元素是否与遍历到的元素相等；2.其他细节如直接使用字符比较。
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        // write code here
        Stack<Character> stack = new Stack<>();//辅助栈存放字符
        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);//遍历到的字符
            //如果是左符号，添加对应的右符号
            if(ch == '(') {//字符ch是基本数据类型，可以直接用==判断是否相等
                stack.push(')');
            }else if(ch == '[') {
                stack.push(']');
            }else if(ch == '{') {
                stack.push('}');
            //如果栈空，说明刚开始的是右符号，直接返回false
            //如果遍历到的字符与栈顶不相等，说明不匹配，同样返回false
            //另一种理解思路：必须有左符号才能匹配右符号
            }else if(stack.isEmpty() || ch != stack.pop()) {
                return false;
            }
        }
        return stack.isEmpty();//判断栈是否为空，不为空说明有左符号
    }
}
```

## BM45 滑动窗口的最大值（难）

```java
//暴力求解--超时，数据规模大的情况下不能ac
//遍历数组每一个元素，再遍历size大小的窗口中元素，找到最大值加入到结果集合。
//补充：官方的暴力求解同该方法，同样不能ac，应该是后期加了大数组测试用例。
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size) {
        ArrayList<Integer> res = new ArrayList<>();//结果集合
        for(int i = 0; i <= num.length - size; i++) {//遍历原数组
            int max = Integer.MIN_VALUE;//max用来保存每个窗口的最大值，官方这里用0表示不太好。
            for(int j = i; j < i + size; j++) {//遍历每个窗口
                if(num[j] > max) {
                    max = num[j];//更新max
                }
            }
            res.add(max);//最大值保存到结果集合
            //max = Integer.MIN_VALUE;//重置max多余步骤
        }
        return res;
    }
}

//单调队列--用双端队列模拟单调队列
//思路：要求每个滑动窗口的最大值，我们可以采用单调队列。首先针对第一个滑动窗口，遍历数组，如果数组元素值小于队尾元素值，直接入队；如果数组元素小于队尾元素，不停出队直到队尾元素大于数组元素或者队列为空。--原因：对每个滑动窗口来说，如果新加入的元素值大于前面的元素值，那么前面的元素值不起作用，但如果新加入的元素值小于前面的元素值，那该元素值可能是后面滑动窗口内的最大值，需要保留。
//思路：接上面的思路。处理完第一个窗口，队首元素加入到结果集合。遍历剩下的数组元素，总体思路是，每遍历一个元素，即对应一个新窗口的最大值，找到并加入集合。详细来说就是，每遍历一个元素，先判断旧窗口第一个元素是否等于队列首元素，如果相等出队。剩下的就和处理第一个滑动窗口类似，每次查看该元素与队尾元素大小，小的入队，大的出队后入队。
//本题很难，leetcode上的难度也是hard，其实算是单调队列的一道经典题，本质上和滑动窗口关系不大。
//这篇解题报告和官解差不多，官解单调队列里放的是数组下标，感觉凭空增加了思考难度，有点多此一举，可能是出于效率方面的考虑？另外官解考虑了滑动窗口尺寸size大于数组长度的情况、size本身不合法的情况，实际上在测试用例中没有这两个的边界测试用例。为了代码思路更加清晰，这篇解题报告就没有写这些。
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size) {
        ArrayList<Integer> res = new ArrayList<>();//结果集合
        Deque<Integer> queue = new ArrayDeque<>();//用双端队列来模拟单调队列
        //第一个窗口
        for(int i = 0; i < size; i++) {
            while(!queue.isEmpty() && num[i] > queue.peekLast()) {//新数组元素大于队列尾元素，从队尾出队
                queue.pollLast();
            }
            queue.offer(num[i]);//入队
        }
        //将第一个窗口的最大值加入到结果集合中
        res.add(queue.peekFirst());//加入到结果集合中。
        //处理接下来的窗口(本题逻辑重点，主要是画图理解过程)
        for(int j = size; j < num.length; j++) {
            //窗口第一个元素等于队头元素，因为窗口滑动，此时要进行出队操作
            if(!queue.isEmpty() && queue.peekFirst() == num[j - size]) {//队列头元素值等于要出滑动窗口的元素值
                queue.poll();//出队
            }
            //和处理第一个窗口类似，如果更大，就将队列中小的出队；如果更小，就直接入队（本题核心）
            while(!queue.isEmpty() && num[j] > queue.peekLast()) {//同第一个窗口
                queue.pollLast();//出队
            }
            queue.offer(num[j]);//入队
            //注意更新结果集合，除第一个窗口外，每遍历一个数组元素，即有一个窗口最大值加入集合
            res.add(queue.peekFirst());//队首加入到结果集合
        }
        return res;
    }
}
```

## BM46 最小的k个数

```java
//堆排序
//利用PriorityQueue，将所有元素放入堆中，依次取出小顶堆堆顶元素，即为最小的k个元素。本质上仍然是排序。
import java.util.*;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        //结果集合
        ArrayList<Integer> res = new ArrayList<>();
        //特例
        if(k == 0 || input.length == 0) return res;
        //优先级队列--小根堆
        //知识点：优先级队列基于优先级堆的无界优先级queue。 
        //优先级队列的元素根据其natural ordering或队列构造时提供的Comparator进行排序 ，具体取决于使用的构造函数。
        PriorityQueue<Integer> pq = new PriorityQueue<>((o1,o2)->o1.compareTo(o2));
        //全部放入堆中
        for(int i = 0; i < input.length; i++) {
            pq.offer(input[i]);
        }
        //取出最小的k个数，放进结果集合
        for(int i = 0; i < k; i++) {
            res.add(pq.poll());
        }
        //返回结果集合
        return res;
    }
}

//快速排序
//Arrays.sort(arr)默认是快排，即通过快排从小到大排序数组，然后取数组前k个元素。
//这题两种方法本质上都是从小到大排序数组，输出前k个元素。并且都是借用了api，实际上面试一般要求手写堆排或者快排。
//相关排序算法会总结到一起，我会在下面给出本题的手写堆排和快排的实现。
import java.util.*;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        //结果集合
        ArrayList<Integer> res = new ArrayList<>();
        //特例
        if(k == 0 || input.length == 0) return res;
        //调用api（底层实现是快速排序）
        Arrays.sort(input);
        //数组前k个数加入到结果集合中
        for(int i = 0; i < k; i++) {
            res.add(input[i]);
        }
        //返回结果集合
        return res;
    }
}

//堆排序--手写堆排算法，实现数组排序

//快速排序--手写快速排序，实现数组排序
```

