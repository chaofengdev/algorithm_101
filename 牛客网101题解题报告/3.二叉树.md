## BM23 二叉树的前序遍历

```java
//递归
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    ArrayList<TreeNode> list = new ArrayList<>();
    public int[] preorderTraversal (TreeNode root) {
        // write code here
        preOrder(root);
        int[] arr = new int[list.size()];
        for(int i = 0 ; i < list.size(); i++) {
            arr[i] = list.get(i).val;
        }
        return arr;
    }
    public void preOrder(TreeNode root) {
        if(root == null) return ;
        list.add(root);
        preOrder(root.left);
        preOrder(root.right);
    }
}

//迭代--利用栈实现前序遍历的非递归写法
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    public int[] preorderTraversal (TreeNode root) {
        // write code here
        if(root == null) return new int[0];//空树返回空数组
        //栈
        Stack<TreeNode> stack = new Stack<>();
        //结果集合
        List<Integer> res = new ArrayList<>();
        //将根节点压栈
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            res.add(node.val);//保存进结果集合
            if(node.right != null) {//右子树进栈
                stack.push(node.right);
            }
            if(node.left != null) {
                stack.push(node.left);//左子树进栈
            }
        }
        //将结果集合的数据转存到数组中
        int[] arr = new int[res.size()];
        int index = 0;
        for(int val : res) {
            arr[index++] = val;
        }
        return arr;
    }
}

//迭代：与中序遍历迭代法统一的版本
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    public int[] preorderTraversal (TreeNode root) {
        // write code here
        //辅助栈
        Stack<TreeNode> stack = new Stack<>();
        //结果集合
        List<Integer> list = new ArrayList<>();
        //空树
        if(root == null) return new int[0];
        while(root != null || !stack.isEmpty()) {//循环判断条件
            while(root != null) {
                list.add(root.val);//先访问根节点
                stack.push(root);
                root = root.left;//再访问左子节点
            }
            TreeNode node = stack.pop();
            root = node.right;//再访问右子节点
        }
        //返回结果
        int[] arr = new int[list.size()];
        int index = 0;
        for(int val : list) {
            arr[index++] = val;
        }
        return arr;
    }
}
```

## BM24 二叉树的中序遍历

```java
//递归
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    List<Integer> list = new ArrayList<>();
    public int[] inorderTraversal (TreeNode root) {
        // write code here
        inOrder(root);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
    //中序遍历
    public void inOrder(TreeNode root) {
        if(root == null) return ;
        inOrder(root.left);
        list.add(root.val);
        inOrder(root.right);
    }
}
//迭代：考研的常考题，可以和前序遍历统一记忆
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @return int整型一维数组
     */
    public int[] inorderTraversal (TreeNode root) {
        // write code here
        //辅助栈
        Stack<TreeNode> stack = new Stack<>();
        //结果集合
        List<Integer> list = new ArrayList<>();
        //空树返回空数组
        if(root == null) return new int[0];
        //栈不为空或树结点不为空
        while (!stack.isEmpty() || root != null) {
            while(root != null) {//循环遍历左子树
                stack.push(root);
                root = root.left;
            }
            TreeNode node = stack.pop();//访问该结点
            list.add(node.val);//加入结果集合
            root = node.right;//指向右节点
        }
        //结果保存到数组中
        int[] arr = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            arr[i] = list.get(i);
        }
        return arr;
    }
}
```

## BM25 二叉树的后序遍历

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    List<Integer> list = new ArrayList<>();
    public int[] postorderTraversal (TreeNode root) {
        // write code here
        postOrder(root);
        int[] arr = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            arr[i] = list.get(i);
        }
        return arr;
    }
    public void postOrder(TreeNode root) {
        if(root == null) return ;
        postOrder(root.left);
        postOrder(root.right);
        list.add(root.val);
    }
}
//迭代：可能的考题，频率没有中序遍历高
//这里初学比较难，主要理解以下内容：
//1.理解pre的作用；2.结合前序和中序，梳理后序的过程与前序中序的不同，比较三者代码的区别。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    public int[] postorderTraversal (TreeNode root) {
        // write code here
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;//标志指针，表示该结点已经被访问过
        //stack.push(root);
        while(!stack.isEmpty() || root != null) {//理由同前序、中序
            while(root != null) {//遍历左子树并加入栈
                stack.push(root);
                root = root.left;
            }
            TreeNode node = stack.pop();//取出栈中的元素
            if(node.right != null && node.right != pre) {//结点有右子树且右子树没有被访问过
                stack.push(node);//结点入栈
                root = node.right;//先访问右子树，注意这里不要随手写成root=root.right
            }else {//结点没有右子树或者右子树访问过
                list.add(node.val);
                pre = node;//表示该结点已经被访问过
            }
        }
        //返回结果
        int[] arr = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            arr[i] = list.get(i);
        }
        return arr;
    }
}
```

## BM26 二叉树的层序遍历

```java
//必背算法--层序遍历
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        // write code here
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            ArrayList<Integer> list = new ArrayList<>();//记录二叉树的一行
            for(int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
            }
            res.add(list);
        }
        return res;
    }
}
//递归--很少用
//略
```

## BM27 之字形打印二叉树

```java
//层序遍历
//利用index记录层数或奇偶层数
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        if(pRoot == null) return res;//判空
        queue.offer(pRoot);
        int index = 0;//索引标志，偶数时为奇数层
        while(!queue.isEmpty()) {
            int len = queue.size();
            ArrayList<Integer> list = new ArrayList<>();
            for(int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                if(index % 2 == 0) {
                    list.add(node.val);//尾插法（正序）
                }else {
                    list.add(0,node.val);//头插法（逆序）
                }
                if(node.left != null) {
                    queue.offer(node.left);
                }
                if(node.right != null) {
                    queue.offer(node.right);
                }
            }
            index++;
            res.add(list);
        }
        return res;
    }

}
//层序遍历
//利用标志位flag
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        if(pRoot == null) return res;//判空
        queue.offer(pRoot);
        boolean flag = true;//flag为true正序，false逆序
        while(!queue.isEmpty()) {
            int len = queue.size();
            ArrayList<Integer> list = new ArrayList<>();
            for(int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                if(flag) {
                    list.add(node.val);//尾插法（正序）
                }else {
                    list.add(0,node.val);//头插法（逆序）
                }
                if(node.left != null) {
                    queue.offer(node.left);
                }
                if(node.right != null) {
                    queue.offer(node.right);
                }
            }
            flag = !flag;
            res.add(list);
        }
        return res;
    }

}
//双栈法
//不符合直觉，对于本题来说不是最优解，略
```

## BM28 二叉树的最大深度

```java
//递归
//二叉树的深度等于根节点一层加上左右子树深度的最大值，每个子树都看成是根节点，继续使用上述方法求深度
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    public int maxDepth (TreeNode root) {
        // write code here
        //终止条件/递归出口：空树的深度为0
        if(root == null) return 0;//递归出口：空树，深度为0
        //本级任务：求左右子树深度
        int left_depth = maxDepth(root.left);//求左子树的深度
        int right_depth = maxDepth(root.right);//求右子树的深度
        //返回值：返回以root为根节点的二叉树的深度
        return Math.max(left_depth, right_depth) + 1;//返回二叉树的深度
    }
}
//层序遍历1
//层序遍历二叉树得到集合List<List<Integer>>，层数即为深度
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    public int maxDepth (TreeNode root) {
        // write code here
        List<List<Integer>> lists = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return 0;//空树深度为0，不加这句会报空指针异常
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
            }
            lists.add(list);
        }
        return lists.size();
    }
}
//层序遍历2
//另一种写法，就是在上面的写法基础上改一改。比如不用List<List<Integer>>来记录层序遍历的结果，直接使用一个depth变量记录遍历的层数，该层数即为二叉树的深度。这样写甚至List<Integer>都不需要记录，这里为了代码完整性还是将层序遍历结果记录在了List<Integer>
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    public int maxDepth (TreeNode root) {
        // write code here
        List<List<Integer>> lists = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return 0;//空树深度为0，不加这句会报空指针异常
        queue.offer(root);
        List<Integer> list = new ArrayList<>();
        int depth = 0;
        while(!queue.isEmpty()) {
            int len = queue.size();
            //List<Integer> list = new ArrayList<>();
            for(int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
            }
            depth++;
        }
        return depth;
    }
}
```

## BM29 二叉树中和为某一值的路径

```java
//递归--下面的写法不是最简洁的，但可以最大程度体现算法的思路。
//我们可以在根节点每次往下一层的时候，将sum减去节点值，最后检查是否完整等于0. 
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return bool布尔型
     */
    public boolean hasPathSum (TreeNode root, int sum) {
        // write code here
        //递归出口：叶子结点且sum-root.val为0
        if(root == null) return false;//空结点无路径(本题难点，测试用例可以看出来，空树的时候不考虑sum值)
        if(root.left == null && root.right == null && sum - root.val == 0) {
            return true;
        }
        //本级条件：分别判断左右子树有没有该路径
        boolean res1 = hasPathSum(root.left, sum - root.val);
        boolean res2 = hasPathSum(root.right, sum - root.val);
        //返回值：有一个为true，说明存在满足条件的路径
        return res1 || res2;
    }
}

//深度优先遍历--这里选择类先序遍历，实际上左右子树谁先遍历无所谓
//深度优先遍历树，用栈来保存根节点到每个结点的路径和，如果有路径和为sum，直接返回true，否则返回false
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return bool布尔型
     */
    public boolean hasPathSum (TreeNode root, int sum) {
        // write code here
        if(root == null) return false;//特例
        Stack<TreeNode> stack = new Stack<>();//dfs辅助栈
        Stack<Integer> stack2 = new Stack<>();//记录从根节点到该结点目前的路径和
        stack.push(root);//根结点入栈
        stack2.push(root.val);//根节点值入栈
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();//弹出结点
            int cur_sum = stack2.pop();//弹出到该节点为止的当前路劲和
            if(node.left == null && node.right == null && cur_sum == sum) {//叶子且路径和为sum
                return true;
            }
            if(node.left != null) {//左子结点与路径和入栈
                stack.push(node.left);
                stack2.push(cur_sum + node.left.val);
            }
            if(node.right != null) {//右子节点与路径和入栈
                stack.push(node.right);
                stack2.push(cur_sum + node.right.val);
            }
        }
        return false;//没有找到路径和为sum直接返回false
    }
}

//层序遍历--这题只要能保存路径和，任何一种遍历方式都可以，只是有些效率高有些效率低，很明显求路径和天然符合dfs逻辑
//多加一个队列来保存从根节点当前结点的路径和，这样如果是子节点且路径和为sum，直接返回true
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return bool布尔型
     */
    public boolean hasPathSum (TreeNode root, int sum) {
        // write code here
        if(root == null) return false;
        Queue<TreeNode> queue = new ArrayDeque<>();//层次遍历队列
        Queue<Integer> queue2 = new ArrayDeque<>();//辅助队列，用来保存当前路径和
        //List<List<Integer>> lists = new ArrayList<>();
        queue.offer(root);
        queue2.offer(root.val);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();//遍历到当前结点
            int cur_sum = queue2.poll();//当前结点路径和
            if(node.left == null && node.right == null && cur_sum == sum) {//叶子结点且路径和为sum
                return true;
            }
            if(node.left != null) {//左子结点入队列，左子节点值加当前路径和入队列
                queue.offer(node.left);
                queue2.offer(node.left.val + cur_sum);
            }
            if(node.right != null) {//右子节点入队列，右子节点加当前路径和入队列
                queue.offer(node.right);
                queue2.offer(node.right.val + cur_sum);
            }
        }
        return false;//没有找到路径和为sum，直接返回false
    }
}
```

## BM30 二叉搜索树与双向链表

```java
//中序遍历--这题真的值得仔细思考，非常有意思。
//二叉搜索树的中序遍历是递增序列，现在就是如何在中序遍历的过程中，改变指针，使得树转变为双向链表
//根据中序遍历递归算法的逻辑，假设左子树改变完，pre指向前一个结点，root指向当前结点，连接pre和root，连接后更新pre为当前结点
//那么如何返回双向链表的head呢？开始时pre和head都初始化为null，中序遍历会遍历到左下角的结点，该结点是双向链表的第一个结点，pre和head都初始化为指向该结点的指针，因为pre是全局变量，后面就用pre一步一步连接root，最后返回head即可。
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    TreeNode pre = null;//指向当前遍历结点的前一个结点，当前结点在递归时始终为root
    TreeNode head = null;//返回的头指针
    public TreeNode Convert(TreeNode root) {
        return InOrder(root);
    }
    //中序遍历的过程中，修改指针，将树转换成链表
    public TreeNode InOrder(TreeNode root) {
        if(root == null) {//空树直接返回null
            return null;
        }
        InOrder(root.left);//遍历左子树
        if(pre == null) {//找到最小值，初始化pre和head（本题难点在于初始化pre和head）
            head = root;
            pre = root;
        }else {//当前结点与上一结点连接，将pre设置为当前值
            pre.right = root;
            root.left = pre;
            pre = root;
        }
        InOrder(root.right);//遍历右子树
        return head;//返回头指针
    }
}

//非递归中序遍历
//同样在遍历二叉树的基础上，改变指针引用，将二叉树改变成双向链表
//想要做好这类题，非递归中序遍历的写法一定要非常熟练
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    public TreeNode Convert(TreeNode root) {
        //特例
        if(root == null) return null;
        //辅助栈
        Stack<TreeNode> stack = new Stack<>();
        //辅助指针
        TreeNode pre = null;
        TreeNode head = null;
        //标志位，用来确定head
        boolean isFirst = true;
        //根节点入栈
        //stack.push(pRootOfTree);//这里根节点提前入栈是错误写法，看了我一个小时才看出来，无语...
        //中序遍历二叉树
        while(root != null || !stack.isEmpty()) {
            while(root != null) {//结点依次入栈
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();//结点出栈
            if(isFirst) {//确定head、pre指向
                head = root;
                pre = head;
                isFirst = false;
            }else {//连接两个结点
                pre.right = root;
                root.left = pre;
                pre = root;
            }
            root = root.right;
        }
        return head;
    }
}
```

## BM31 对称的二叉树

```java
//递归
//本质上就是看透题目，遵循1.递归出口；2.本级任务；3.返回值来书写递归方法
//递归第一步要确定递归函数的实际意义，要非常精确
//该意义建立在第一层的逻辑梳理上。
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    boolean isSymmetrical(TreeNode root) {
        if(root == null) return true;//根节点单独考虑，事实上换个思路就不需要单独考虑了。
        return dfs(root.left,root.right);
    }
    //判断左右两棵子树是否相同
    public boolean dfs(TreeNode left, TreeNode right) {
        //递归出口
        if(left == null && right == null) {//左右子树都为空显然是相同的
            return true;
        }
        if(left == null || right == null) {//左子树或者右子树为空显然不相同
            return false;
        }
        if(left.val != right.val) {//结点值不相等，不相同
            return false;
        }
        //本级任务
        boolean res1 = dfs(left.left,right.right);//左子树的左节点和右子树的右节点是否相同
        boolean res2 = dfs(left.right,right.left);//左子树的右节点和右子树的左节点是否相同
        //返回值
        return res1 && res2;//两个结果都相同才能保证二叉树对称
    }
}

//迭代
//通过两个辅助栈，遍历root的两个子树，左子树按照先左后右的方式遍历，右子树按照先右后左的方式遍历，根据层序遍历的理解，可以发现只要子树对称，则左右子树的遍历序列相等，所以判断两个子树是否相等即可
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    boolean isSymmetrical(TreeNode root) {
        //辅助队列
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        //根节点为空
        if(root == null) return true;
        //添加两个子树，用来层序遍历判断两子树是否对称（相等）
        queue1.offer(root.left);
        queue2.offer(root.right);
        //遍历二叉树
        while(!queue1.isEmpty() && !queue2.isEmpty()) {
            TreeNode node1 = queue1.poll();
            TreeNode node2 = queue2.poll();
            if(node1 == null && node2 == null) {
                continue;//易错点
            }
            if(node1 == null || node2 == null || node1.val != node2.val) {
                return false;
            }
            //左右添加
            queue1.offer(node1.left);
            queue1.offer(node1.right);
            //右左添加
            queue2.offer(node2.right);
            queue2.offer(node2.left);
        }
        return true;//流程走完没有发现不对称的情况，直接返回真表示对称成立
    }
}
```

## BM32 合并二叉树

```java
//递归
//看起来比较困难，但实际很简单的。
//很多时候递归的解法很优雅，代码很简洁
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param t1 TreeNode类 
     * @param t2 TreeNode类 
     * @return TreeNode类
     */
    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {
        // write code here
        //递归出口
        if(t1 == null && t2 == null) return null;
        if(t1 == null) return t2;
        if(t2 == null) return t1;
        //本级任务
        TreeNode root = new TreeNode(t1.val + t2.val);//建立根节点
        root.left = mergeTrees(t1.left, t2.left);//左子树
        root.right = mergeTrees(t1.right,t2.right);//右子树
        //返回值
        return root;
    }
}

//迭代
//层序遍历--使用三个辅助队列，第一个队列queue用于暂存合并后的二叉树的层次遍历结点，第二个队列q1用于暂存t1的层次遍历结点，第三个队列q2用于暂存t2的层次遍历结点。但是本题精彩的是，并不需要处理所有的结点，当t1或者t2其中一个子树为空时，直接用node.left或者node.right指向存在的子树，这样就避免了处理空节点与普通结点相加。同时注意相关结点也不需要入队列，简化了逻辑。
//这是非常好的思路，巧妙的处理了两棵树存在的大量不同的结点，值得借鉴。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param t1 TreeNode类 
     * @param t2 TreeNode类 
     * @return TreeNode类
     */
    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {
        // write code here
        //判空
        if(t1 == null && t2 == null) return null;
        if(t1 == null) return t2;
        if(t2 == null) return t1;
        //辅助队列
        Queue<TreeNode> queue = new LinkedList<>();//合并后树的遍历队列
        Queue<TreeNode> queue1 = new LinkedList<>();//t1的遍历队列
        Queue<TreeNode> queue2 = new LinkedList<>();//t2的遍历队列
        //合并后的根节点
        TreeNode root = new TreeNode(t1.val + t2.val);
        //相关结点入队列
        queue.offer(root);
        queue1.offer(t1);
        queue2.offer(t2);
        //遍历两棵树，合并结点值
        while(!queue1.isEmpty() && !queue2.isEmpty()) {
            TreeNode node1 = queue1.poll();
            TreeNode node2 = queue2.poll();
            TreeNode node = queue.poll();
            //左子树结点合并
            if(node1.left != null && node2.left != null) {//左右子节点都存在
                TreeNode new_node = new TreeNode(node1.left.val + node2.left.val);
                node.left = new_node;
                queue.offer(node.left);
                queue1.offer(node1.left);
                queue2.offer(node2.left);
            }else if(node1.left != null) {//左子节点存在
                node.left = node1.left;//难点，这里因为有棵树不存在，直接将存在的树挂上面
                //queue.offer(node.left);
            }else if(node2.left != null){//右子节点存在
                node.left = node2.left;//难点，这里因为有棵树不存在，直接将存在的树挂上面
                //queue.offer(node.left);
            }
            //右子树结点合并
            if(node1.right != null && node2.right != null) {//左右子节点都存在
                TreeNode new_node = new TreeNode(node1.right.val + node2.right.val);
                node.right = new_node;
                queue.offer(node.right);
                queue1.offer(node1.right);
                queue2.offer(node2.right);
            }else if(node1.right != null) {//左子节点存在
                node.right = node1.right;
                //queue.offer(node.right);
            }else if(node2.right != null){//右子节点存在
                node.right = node2.right;
                //queue.offer(node.right);
            }
        }
        return root;
    }
}
```

## BM33 二叉树的镜像

```java
//先序遍历--自顶向下
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return TreeNode类
     */
    public TreeNode Mirror (TreeNode root) {
        // write code here
        //递归出口
        if(root == null) return null;
        //本级任务
        //交换左右结点
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        //左右子树分别交换左右结点
        Mirror(root.right);
        Mirror(root.left);
        //返回值
        return root;
    }
}

//后序遍历--自底向上
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return TreeNode类
     */
    public TreeNode Mirror (TreeNode root) {
        // write code here
        //递归出口
        if(root == null) return null;
        //本级任务
        TreeNode left = Mirror(root.left);
        TreeNode right = Mirror(root.right);
        root.left = right;
        root.right = left;
        //返回值
        return root;
    }
}

//先序遍历非递归--自顶向下
//这里用的是先序遍历特有的非递归写法
//这里需要站的更高一点来看待这道题，简单来讲就是，先序遍历的过程中，始终遵循“根左右”的顺序，那我们在遍历的过程中，每次交换左右子树，遍历的过程依旧不变，不就能实现自己的目的了吗。还是很清晰易懂的。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return TreeNode类
     */
    public TreeNode Mirror (TreeNode root) {
        // write code here
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        TreeNode cur = root;
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node.right != null) {
                stack.push(node.right);
            }
            if(node.left != null) {
                stack.push(node.left);
            }
            //交换左右子节点
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
        }
        return root;
    }
}
```

## BM34 判断是否为二叉搜索树

```java
//暴力求解
//二叉搜索树的中序遍历是递增序列，直接中序遍历二叉树，检查序列是否是递增序列即可。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    List<Integer> list = new ArrayList<>();
    public boolean isValidBST (TreeNode root) {
        // write code here
        InOrder(root);
        for(int i = 0; i <= list.size() - 2; i++) {
            if(list.get(i) > list.get(i+1)) {
                return false;
            }
        }
        return true;
    }
    //中序遍历二叉搜索树
    public void InOrder(TreeNode root) {
        if(root == null) {
            return ;
        }
        InOrder(root.left);
        list.add(root.val);
        InOrder(root.right);
        return ;
    }
}
//暴力求解
//核心思想同上，但非递归遍历二叉树
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    public boolean isValidBST (TreeNode root) {
        // write code here
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        TreeNode cur = root;
        while(!stack.isEmpty() || cur != null) {
            while(cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }
        for(int i = 0; i < list.size() - 1; i++) {
            if(list.get(i) > list.get(i + 1)) {
                return false;
            }
        }
        return true;
    }
}


//递归--中序遍历
//讲真，这题真的很精彩。左右子树均为二叉搜索树且左节点值<根节点值<右节点值，并不能保证root为根的二叉树是二叉搜索树，必须要左右子树均为二叉搜索树的同时，左子树最大值小于根节点值，根节点值小于右子树的最小值。要达到这个目的，首先需要中序遍历，先判断左子树是否是二叉搜索树，pre指针指向最左边的结点（当然也可以看成是左子树的最大结点，角度不同，这两个并不是同一个结点），判断二叉搜索树是否成立，不成立直接返回false，成立则将pre改成root，再遍历右子树，判断右子树是否是二叉搜索树。
//总之本题没有那么直观，我再想想有没有更好的中序遍历解答。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    TreeNode pre = null;//用来记录前一个结点
    public boolean isValidBST (TreeNode root) {
        // write code here
        if(root == null) return true;//空树为二叉搜索树
        boolean res1 = isValidBST(root.left);//判断左子树是否为二叉搜索树
        if(pre != null && pre.val >= root.val) {//pre结点值大于等于root结点值
            return false;
        }
        pre = root;//更新pre
        boolean res2 = isValidBST(root.right);//判断有子树是否为二叉搜索树
        return res1 && res2;
    }
}
```

## BM35 判断是否为完全二叉树

```java
//带标志位的层次遍历，isComplete遇到第一个null结点时置为true，如果是完全二叉树，后续所有结点均为null，否则不是完全二叉树
//这题看起来很简单，但没做过，不太好想到。可能会误入歧途，去判断倒数第二层的结点数，这些和完全二叉树不等价。完全二叉树的等价定义应该是满二叉树去掉最后n个结点，中间不能有null结点出现。为了实现该定义，可以在层序遍历的过程中添加标志位判断。

import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    public boolean isCompleteTree (TreeNode root) {
        // write code here
        Queue<TreeNode> queue = new LinkedList<>();//这里不要用ArrayDeque，会出现空指针异常
        queue.offer(root);
        boolean isComplete = false;//表示首次出现null结点
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node == null) {//遇到第一个null结点
                isComplete = true;
                continue;//退出循环
            }
            if(isComplete) {//遇到第一个null结点之后，还有非null结点，即非完全二叉树
                return false;
            }
            queue.offer(node.left);
            queue.offer(node.right);
        }
        return true;//是完全二叉树
    }
}
```

## BM36 判断是否为平衡二叉树

```java
//本题是简化版本，只考虑平衡性，不考虑子树是否是二叉搜索树
//即本题意思是，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
//递归--自顶向下
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        //递归出口
        if(root == null) return true;//约定空树是二叉平衡树
        if(depth(root.left) - depth(root.right) > 1 || 
           depth(root.left) - depth(root.right) < -1) {//左右子树高度差不超过1
           return false; 
        }
        //本级任务
        boolean res1 = IsBalanced_Solution(root.left);
        boolean res2 = IsBalanced_Solution(root.right);
        //返回值
        return res1 && res2;
    }
    //求树深度
    public int depth(TreeNode root) {
        //递归出口
        if(root == null) return 0;
        //本级任务：求左右子树深度
        int left = depth(root.left);
        int right = depth(root.right);
        //返回：本树深度
        return Math.max(left,right) + 1;
    }
}

//递归--自底向上
//明确depth的含义，另外我对这里的“自底向上”没有完全理解，我的理解只是将depth的含义加深了一下，使得函数depth在计算深度的同时，还能判断是否为平衡二叉树。
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null) return true;
        if(depth(root) == -1) {
            return false;
        }else {
            return true;
        }
    }
    //求树高度，如果树平衡，直接返回树高度；如果树不平衡，返回-1表示不平衡
    public int depth(TreeNode root) {
        //出口
        if(root == null) return 0;
        //本级任务
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        //返回值
        if(Math.abs(left - right) > 1) {//左右子树高度差大于1
            return -1;
        }else {
            return Math.max(left,right) + 1;//返回树的高度
        }
    }
}
```

## BM37 二叉搜索树的最近公共祖先

```java
//从根节点开始，找到根节点到p的路径，找到根节点到q的路径，两条路径有重合的地方，所有重合的结点都是pq两个结点的公共祖先，最后一次重合的结点即为我们需要的结点。
//官方称之为路径比较法，其实就是暴力求解。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int p, int q) {
        // write code here
        List<Integer> pathP = getPath(root,p);
        List<Integer> pathQ = getPath(root,q);
        int res = 0;//保存结果--最近公共祖先结点值
        //求两条路径最后一个相同结点值
        for(int i = 0; i < pathP.size() && i < pathQ.size(); i++) {
            int x = pathP.get(i);
            int y = pathQ.get(i);
            if(x == y) {//相等
                res = x;//临时保存在res中
            }else {//不相等
                break;//退出循环
            }
        }
        return res;//返回结果--最近公共祖先结点值
    }
    //找到root到结点值target的结点路径，保存到path集合中
    public List<Integer> getPath(TreeNode root, int target) {
        List<Integer> path = new ArrayList<>();//新建集合
        TreeNode cur = root;
        while(cur.val != target) {
            path.add(cur.val);
            if(target < cur.val) {//利用二叉搜索树的性质，所以该方法不是通用方法
                cur = cur.left;
            }else {
                cur = cur.right;
            }
        }
        path.add(cur.val);//当cur.val==target时，将cur.val加入集合
        return path;
    } 
}

//递归
//如果两个结点在root的左右子树中，则最近公共祖先为root；如果均在左子树，则最近公共祖先在root.left中，否则在root.right中。
//这里简化一下写法其实就三行，这里为了体现思路，写的比较详细
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int p, int q) {
        // write code here
        if(root == null) {//空树无公共祖先
            return -1;
        }
        if((p > root.val && q < root.val) || (q > root.val && p < root.val)) {//pq在root左右子树
            return root.val;
        }else if(p <= root.val && q <= root.val) {//pq在root左子树
            int left = lowestCommonAncestor(root.left,p,q);
            return left;
        }else {//pq在root右子树
            int right = lowestCommonAncestor(root.right,p,q);
            return right;
        }
        
    }
}

//递归--更加简洁的写法，但本质和上面一模一样。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int p, int q) {
        // write code here
        if(p < root.val && q < root.val) {//pq均在左子树
            return lowestCommonAncestor(root.left, p, q);
        }
        if(p > root.val && q > root.val) {//pq均在右子树
            return lowestCommonAncestor(root.right, p, q);
        }
        return root.val;//pq一个在左子树一个在右子树，容易发现root结点值即为最近公共祖先（这里其实隐含了root.val==q或者root.val==p的情况）
    }
}
```

## BM38 二叉树结点的最近公共祖先（难）

```java
//官方解答：公共路径求满足条件的公共结点
//拆解为两部分：1.二叉树求根节点到指定结点路径；2.求两个序列的最后一个相同的元素值。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    boolean found = false;//全局变量，表示是否在root为根的树中找到结点（结点值为val）
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        //集合
        List<Integer> path1 = new ArrayList<>();
        List<Integer> path2 = new ArrayList<>();
        //求得两条路径
        getPath(root, o1, path1);
        found = false;//重置全局变量
        getPath(root, o2, path2);
        //求两条路径最后一个公共结点
        int res = 0;//保存结果
        for(int i = 0; i < path1.size() && i < path2.size(); i++) {
            int x = path1.get(i);//这里要注意Integer之间用equals比较，不然会问题。当然这里图省事直接自动拆箱了int
            int y = path2.get(i);
            if(x == y) {
                res = x;//res将会记录最后一次x==y
            }else {
                break;//第一次x!=y时，退出循环
            }
        }
        return res;
    }
    //求root节点到目标结点（该节点值为val）的路径
    //思路：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，
    //同时路径数组增加这个遍历的节点值，
    //一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。
    public void getPath(TreeNode root, int val, List<Integer> path) {
        if(root == null) return ;
        if(found) return ;
        path.add(root.val);//将结点值加入到集合
        if(root.val == val) {//找到值为val的结点
            found = true;
            return ;
        }
        getPath(root.left, val, path);//遍历左子树
        getPath(root.right, val, path);//遍历右子树
        if(found) return ;
        path.remove(path.size()-1);//回溯，这里可以用栈
    }
    
}
//官方解答：直接递归
//这个解答是目前的主流方法，我是真的看不懂，两个月前看了一遍，现在回头看还是不理解。
//这个方法的主要问题是，函数的功能定义不清晰！
//如果函数定义为求以root为根的两个结点o1o2（严格来说是结点值为o1o2，这里为了方便表述就称之为o1o2）的最近公共子节点，那必然不存在lowestCommonAncestor(root.left,o1,o2)和lowestCommonAncestor(root.right,o1,o2)都成立的情况。这里我也很费解。
//找到被广泛接受的两个理由：
//1.函数的功能有三个，给定两个结点p和q
//如果pq都存在，则返回公共祖先；
//如果pq只存在一个，返回存在的一个；
//如果pq都不存在，返回-1
//2.最近公共祖先的定义：
//设节点root为节点p,q的某公共祖先，若其左子节点root.left和右子节点root.right都不是p,q的公共祖先，则称root是“最近的公共祖先” 

import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        if(root == null) return -1;//空树返回-1表示无结点
        if(root.val == o1 || root.val == o2) {//如果找到其中一个结点，直接返回该结点
            return root.val;
        }
        int left = lowestCommonAncestor(root.left, o1, o2);
        int right = lowestCommonAncestor(root.right, o1, o2);
        if(left == -1 && right == -1) {//左右子树都没有结点，返回-1
            return -1;
        }
        if(left == -1) {//左子树无结点
            return right;
        }
        if(right == -1) {//右子树无结点
            return left;
        }
        return root.val;//左右子树均有结点
    }
}
//自己写的解答。leetcode上是可以过的，但这里只能过一部分测试用例，性能太差导致树太大超时。
//先通过find判断结点是否存在，再利用类似二叉搜索树的策略进行递归。
//很遗憾这个方法过不了，应该是两个递归，时间复杂度过大了。但个人认为确实是个简单易懂的好方法，先记录在这里。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        if(root == null) return -1;//空树返回-1表示不存在
        //if(root.val == o1 || root.val == o2) return root.val;//难点，这个条件很容易忽视。若结点（值为pq）其中一个为根节点，则结果为根节点本身
        if(find(root.left, o1) && find(root.left, o2)) { //o1o2均在左子树
            return lowestCommonAncestor(root.left,o1,o2);
        }
        if(find(root.right, o1) && find(root.right, o2)) {//o1o2均在右子树
            return lowestCommonAncestor(root.right,o1,o2);
        }
        return root.val;//o1o2分别在左右子树，即最近公共祖先为根节点
    }
    //判断结点（结点值为val）是否在rootW为根的树中
    //借用这个方法，本题lowestCommonAncestor方法就能和二叉搜索树差不多的写法来解决
    public boolean find(TreeNode root, int val) {//为了避免和root.val混淆，参数名也可以写成target
        if(root == null) return false;//空树不存在结点
        if(root.val == val) return true;//根节点即为要找的结点
        boolean res1 = find(root.left, val);//左子树中有无该结点
        boolean res2 = find(root.right, val);//右子树中有无该结点
        return res1 || res2;//两子树有一个存在该结点即可
    }
}
```

## BM39 序列化二叉树

```java
//官方解答：层次遍历
//序列化：[1,2,3,#,#,6,7,#,#] 其中#用Integer.MAX_VALUE代替
//反序列化：[1,2,3,#,#,6,7,#,#] 从字符串中构建二叉树
//感觉细节处有些不妥，比如用字符形式的Integer.MAX_VALUE代替#字符
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    int INF = Integer.MAX_VALUE;//定义常数
    TreeNode emptyNode = new TreeNode(INF);//该结点用来表示空结点
    String Serialize(TreeNode root) {
        if(root == null) return "";//空树返回空字符串
        Queue<TreeNode> queue = new ArrayDeque<>();//辅助队列
        queue.offer(root);//添加根节点
        StringBuilder sb = new StringBuilder();//字符串对象
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();//从队列中取一个结点（包括叶子结点的空子节点）
            sb.append(node.val+",");//拼接到字符串
            //为了防止emptyNode还有子节点，规定node不能为emptyNode
            if(!node.equals(emptyNode)) {//结点不是空结点（难点）
                if(node.left != null) {//左子树不为空
                    queue.offer(node.left);
                }else {
                    queue.offer(emptyNode);//为空，则添加emptyNode结点
                }
                if(node.right != null) {//右子树不为空
                    queue.offer(node.right);
                }else {
                    queue.offer(emptyNode);//为空，则添加emptyNode结点
                }
            }
        }
        return sb.toString();
    }
    TreeNode Deserialize(String str) {
        if(str.equals("")) return null;//空字符串对应空节点
        String[] strArr = str.split(","); //字符串数组
        int len = strArr.length;//字符串数组的长度
        Queue<TreeNode> queue = new ArrayDeque<>();//辅助队列
        TreeNode root = new TreeNode(Integer.parseInt(strArr[0]));//构建根节点
        queue.offer(root);
        for(int i = 1; i <= len - 2; i += 2) {//遍历strArr每次从中取出左右两个结点对应的val
            TreeNode node = queue.poll();
            int a = Integer.parseInt(strArr[i]);
            int b = Integer.parseInt(strArr[i + 1]);
            if(a != INF) {//左节点不是空结点
                node.left = new TreeNode(a);
                queue.offer(node.left);
            }
            if(b != INF) {//右结点不是空结点
                node.right = new TreeNode(b);
                queue.offer(node.right);
            }
        }
        return root;
    }
}

//自己写的版本：层次遍历
//官方解答稍微有点别扭，1.额外用一个结点表示空结点，实际上没有必要；2.for循环本来没有问题，但是层次遍历while写习惯了。
//这里是根据leetcode的一位同学的解题报告改写的方法，主要思路是：
//序列化过程：正常层次遍历二叉树，但如果遇到空结点，同样加入队列。这样每次从队列取出的结点node可能为空，我们在这里判断一下，如果取出的结点为空，结果序列追加字符串"#,"，如果取出的结点不为空，结果序列追加字符串"x,"。这样最后的结果是[1,2,3,#,#,6,7,#,#,#,#]（[]是为了方便表示，字符串中无此符号）
//反序列化过程：取结果序列的第一个字符串，生成根节点并先入队列。循环中，依次出队列。每次取序列中两个字符串，分别为左右子树。先判断是否是字符串"#"，如果不是，正常建立节点连接左右子树，将结点入队列；如果是，则表示左右子树是空树，不需要建立节点，也不需要将结点入队列，指向左右子树指针置空即可。事实上左右子树指针在创建父节点的时候就是空的。
//反思了一下，其实这个解答和官方本质上是一样的。只能说更容易记忆一点？
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    //将二叉树转化成字符串[1,2,3,#,#,6,7,#,#,#,#]（[]是为了方便表示，字符串中无此符号）
    String Serialize(TreeNode root) {
        if(root == null) return "";//空树返回空字符串
        Queue<TreeNode> queue = new LinkedList<>();//层序遍历辅助栈，该队列可以保存null
        StringBuilder sb = new StringBuilder();//二叉树序列字符串
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();//从队列中取出一个二叉树结点
            if(node == null) {
                sb.append("#"+",");//添加空结点
            }else {//node != null
                sb.append(node.val+",");//添加非空结点
                queue.offer(node.left);
                queue.offer(node.right);
            }
        }
        //System.out.println(sb.toString());
        return sb.toString();//转字符串
    }
    //遍历字符串[1,2,3,#,#,6,7,#,#,#,#]，将其转换回二叉树
    TreeNode Deserialize(String str) {
        if(str == "") return null;//空字符串表示空树
        Queue<TreeNode> queue = new LinkedList<>();//层序遍历的辅助栈
        String[] strArr = str.split(",");//字符串数组保存遍历字符串
        TreeNode root = new TreeNode(Integer.parseInt(strArr[0]));//先创建根节点
        queue.offer(root);
        int index = 1;//遍历字符串数组的索引，从1开始是因为根节点是数组第一个
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();//每次从队列中取一个
            //从序列中取出两个字符串
            String str1 = strArr[index++];
            String str2 = strArr[index++];
            //判断字符串是否为空字符串，空字符串对应null，否则正常入队并连接左右子树
            if(str1.equals("#")) {//左子树对应字符串为"#"
                node.left = null;//这个可以省略，因为新建的结点默认左右子树为空。
            }else {
                node.left = new TreeNode(Integer.parseInt(str1));
                queue.offer(node.left);
            }
            if(str2.equals("#")) {//左子树对应字符串为"#"
                node.right = null;//这个可以省略，因为新建的结点默认左右子树为空。
            }else {
                node.right = new TreeNode(Integer.parseInt(str2));
                queue.offer(node.right);
            }
        }
        return root;
    }
}

//这是参考leetcode上大神写的递归解法，比牛客官方更简洁明了一些。
//递归解法有一定难度，难点体现在反序列化的过程。主要是要熟悉先序中序后序的本质。递归写法还是很简洁的。
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    //先序遍历（递归）序列化二叉树，自顶向下的代码十分好写。
    //先序遍历，结果字符串str = [1,2,#,#,3,6,#,#,7,#,#,]
    String Serialize(TreeNode root) {
        if (root == null) return "#" + ","; //空节点设置为#
        String leftStr = Serialize(root.left);//左子树的序列化字符串
        String rightStr = Serialize(root.right);//右子树的序列化字符串
        return root.val + "," + leftStr + rightStr;//返回序列化字符串
    }
    //先序遍历（递归）反序列化二叉树，有点难度
    //结果字符串str = [1,2,#,#,3,6,#,#,7,#,#,]
    TreeNode Deserialize(String str) {
        //System.out.println(str);
        if (str == "#,") {
            return null;
        }
        String[] strArr = str.split(",");//将字符串按照','分割
        //1.Arrays.asList(temp) 将字符串数组temp转换成list集合
        //2.new LinkedList<>(list); 将List<String>集合转换成LinkedList<String>集合
        Queue<String> queue = new LinkedList<>(Arrays.asList(strArr));//队列中保存了元素值
        TreeNode root = buildTree(queue);//递归构建二叉树
        return root;
    }
    //根据队列中的元素，递归构建二叉树
    //这里的写法很巧妙。
    TreeNode buildTree(Queue<String> queue) {
        String str = queue.poll();//出队
        if(str.equals("#")) return null;//这里务必要用equals，字符串比较用equals
        TreeNode root = new TreeNode(Integer.parseInt(str));//新建结点
        root.left = buildTree(queue);//构建左子树
        root.right = buildTree(queue);//构建右子树
        return root;
    }
}
```

## BM40 重建二叉树

```java

```

## BM41 输出二叉树的右视图

```java

```

