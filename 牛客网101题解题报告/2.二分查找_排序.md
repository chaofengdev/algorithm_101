## BM17 二分查找

```
//方法1：遍历有序数组，不符合题意，要求使用二分查找
//...

//方法2：二分查找--经典写法1
//参考链接：https://www.youtube.com/watch?v=RH3tZldhjJ0
import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        int left = 0;//左指针
        int right = nums.length - 1;//右指针
        while(left <= right) {//难点：理解退出循环时，left==right+1或者right==left-1
            int mid = left + (right - left)/2;//取中间位置的值，防止整型溢出
            if(target == nums[mid]) {//找到目标值
                return mid;
            }else if(target < nums[mid]) {//目标值小于中间值，所以在左区间重新找目标值
                right = mid - 1;
            }else if(target > nums[mid]) {//目标值大于中间值，所以在右区间重新找目标值
                left = mid + 1;
            }
        }
        return -1;//整个区间没有找到目标值，按题目要求返回-1
    }
}

//以上的写法还有一种替代写法，该写法主要是while循环条件变成left<right，这样退出while循环时，left==right，此时需要单独判读nums[left]与target的大小关系。另外需要考虑nums.length==0的情况，对应测试用例中的nums数组为空。
//二分查找--经典写法2
import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        if(nums.length == 0) return -1;
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {//难点：理解退出循环时，left==right，即此时nums[left]与target的大小关系还没有判断
            int mid = left + (right - left)/2;
            if(target == nums[mid]) {//这种写法，此处如果不能直接退出，容易死循环。常见错误。
                return mid;
            }else if(target < nums[mid]) {
                right = mid - 1;
            }else if(target > nums[mid]) {
                left = mid + 1;
            }
        }
        if(nums[left] == target) return left;//需要单独判断nums[left]与target大小关系
        return -1;
    }
}

//上面两种写法都需要掌握。
//事实上二分查找里面的水很深，这是最简单的求“查找不重复有序数组中的某个值位置”，事实上往往有序数组是有重复的数字的。
//如：构造数组[1,2,3,3,3,4,5]，target为3，按照上面两个经典的解决方案，只能求得元素3的位置index为3，即中间那个3.
//问题是，我们在很多情况下需要找到最左边的3或者最右边的3，如何设计二分搜索？
//以下给出leetcode原题和参考资料：
//leetcode原题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/
//参考资料2：https://mirrors.gitcode.host/labuladong/fucking-algorithm/think_like_computer/DetailedBinarySearch.html
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length == 0) return new int[]{-1,-1};
        int firstPosition = searchFirst(nums, target);
        int lastPosition = searchLast(nums, target);
        return new int[]{firstPosition, lastPosition};
    }
    //元素第一个位置，没找到返回-1
    public int searchFirst(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;//向下取整
            if(target < nums[mid]) {
                right = mid - 1;
            }else if(target > nums[mid]) {
                left = mid + 1;
            }else if(target == nums[mid]) {
                right = mid;//向左逼近，但不可越过
            }
        }
        if(nums[left] == target) {//此时left==right
            return left;
        }
        return -1;
    }
    //元素最后一个位置，没找到返回-1
    public int searchLast(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;//向上取整
            if(target > nums[mid]) {
                left = mid + 1;
            }else if(target < nums[mid]) {
                right = mid - 1;
            }else if(target == nums[mid]) {
                left = mid;//向右逼近，但不可越过
            }
        }
        //因为是向上取整，所以退出时不一定left==right
        if(nums[right] == target) {//用例：[2,2],3 while退出时left==2，right==1
            return left;
        }
        return -1;
    }
}
```

