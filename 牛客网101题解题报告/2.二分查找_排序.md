## BM17 二分查找

```
//方法1：遍历有序数组，不符合题意，要求使用二分查找
//...

//方法2：二分查找--经典写法1
//参考链接：https://www.youtube.com/watch?v=RH3tZldhjJ0
import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        int left = 0;//左指针
        int right = nums.length - 1;//右指针
        while(left <= right) {//难点：理解退出循环时，left==right+1或者right==left-1
            int mid = left + (right - left)/2;//取中间位置的值，防止整型溢出
            if(target == nums[mid]) {//找到目标值
                return mid;
            }else if(target < nums[mid]) {//目标值小于中间值，所以在左区间重新找目标值
                right = mid - 1;
            }else if(target > nums[mid]) {//目标值大于中间值，所以在右区间重新找目标值
                left = mid + 1;
            }
        }
        return -1;//整个区间没有找到目标值，按题目要求返回-1	
    }
}

//以上的写法还有一种替代写法，该写法主要是while循环条件变成left<right，这样退出while循环时，left==right，此时需要单独判读nums[left]与target的大小关系。另外需要考虑nums.length==0的情况，对应测试用例中的nums数组为空。
//二分查找--经典写法2
import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        if(nums.length == 0) return -1;
        int left = 0;
        int right = nums.length;
        while(left < right) {//难点：理解退出循环时，left==right，即此时nums[left]与target的大小关系还没有判断
            int mid = left + (right - left)/2;
            if(target == nums[mid]) {//这种写法，此处如果不能直接退出，容易死循环。常见错误。
                return mid;
            }else if(target < nums[mid]) {
                right = mid - 1;
            }else if(target > nums[mid]) {
                left = mid + 1;
            }
        }
        if(nums[left] == target) return left;//需要单独判断nums[left]与target大小关系
        return -1;
    }
}

//上面两种写法都需要掌握。
//事实上二分查找里面的水很深，这是最简单的求“查找不重复有序数组中的某个值位置”，事实上往往有序数组是有重复的数字的。
//如：构造数组[1,2,3,3,3,4,5]，target为3，按照上面两个经典的解决方案，只能求得元素3的位置index为3，即中间那个3.
//问题是，我们在很多情况下需要找到最左边的3或者最右边的3，如何设计二分搜索？
//以下给出leetcode原题和参考资料：
//leetcode原题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/
//参考资料1：https://mirrors.gitcode.host/labuladong/fucking-algorithm/think_like_computer/DetailedBinarySearch.html
//参考资料2：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/
//写法1：左闭右开区间--非标准解答，标准解答没有想好
略

//写法二：[left,right]
//左闭右闭区间，没有左闭右开区间那么直观。
class Solution {
    public int[] searchRange(int[] nums, int target) {
        //空数组，特例
        if(nums.length == 0) return new int[]{-1,-1};
        //左位置
        int firstPosition = searchFirst(nums, target);
        //右位置
        int lastPosition = searchLast(nums, target);
        //返回结果
        return new int[]{firstPosition, lastPosition};
    }
    //元素第一个位置，没找到返回-1
    public int searchFirst(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        while(left <= right) {//搜索区间[left,right]
            int mid = left + (right - left) / 2;//向下取整，同时防止整形溢出
            if(nums[mid] > target) {//target在左区间
                right = mid - 1;
            }else if(nums[mid] < target) {//target在右区间
                left = mid + 1;
            }else if(nums[mid] == target) {//target在mid位置
                right = mid - 1;//收缩区间
            }
        }
        //分析left可能的取值:[0,nums.length]
        //如果数组中所有元素值小于target，则返回-1
        //如果数组中不存在元素值等于target，则返回-1
        if(left == nums.length || nums[left] != target) {
            return -1;
        }
        return left;
    }
    //元素最后一个位置，没找到返回-1
    public int searchLast(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {//搜索区间[left,right]
            int mid = left + (right - left) / 2;//向下取整
            if(nums[mid] > target) {
                right = mid - 1;
            }else if(nums[mid] < target) {
                left = mid + 1;
            }else if(nums[mid] == target) {
                left = mid + 1;//收缩区间
            }
        }
        //这里改为检查right越界的情况
        if(right == -1 || nums[right] != target) {
            return -1;
        }
        return right;
    }
}

//写法3：不管开闭区间的写法
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length == 0) return new int[]{-1,-1};
        int firstPosition = searchFirst(nums, target);
        int lastPosition = searchLast(nums, target);
        return new int[]{firstPosition, lastPosition};
    }
    //元素第一个位置，没找到返回-1
    public int searchFirst(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;//向下取整
            if(nums[mid] > target) {
                right = mid - 1;
            }else if(nums[mid] < target) {
                left = mid + 1;
            }else if(nums[mid] == target) {
                right = mid;
            }
        }
        if(nums[left] == target) {//left == right
            return left;
        }
        return -1;
    }
    //元素最后一个位置，没找到返回-1
    public int searchLast(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;//向上取整，防止死循环
            if(nums[mid] > target) {
                right = mid - 1;
            }else if(nums[mid] < target) {
                left = mid + 1;
            }else if(nums[mid] == target) {
                left = mid;
            }
        }
        if(left < nums.length && nums[left] == target) {//[2,2] 3
            return left;
        }
        return -1;
    }
}

//写法4：始终二分的写法，核心就是：一个区间满足条件，那另一个区间不满足条件
略
```



## BM18 二维数组中的查找

```java
 
```

