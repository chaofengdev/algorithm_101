# 图

## 1.抽象数据类型

图由顶点集和边集构成，因此对图的操作也集中在对顶点和边的操作上，主要有以下一些操作：

```java
//创建一个图
createGraph();
//返回图中顶点数
getVexNum();
//返回图中边数
getArcNum();
//给定顶点的位置v，返回对应的顶点值
getVex(v);
//给定顶点值vex，返回在图中的位置
locateVex(vex);
//返回v的第一个邻接点，若没有邻接点，返回-1
firstAdjVex(v);
//返回v相对于w的下一个邻接点，若没有，返回-1
nextAdjVex(v,w);
```

图的抽象数据类型用Java接口表示如下：

```java
public interface IGraph{
	void createGraph();//创建一个图
	int getVexNum();//返回图中顶点数
	int getArcNum();//返回图中边数
	Object getVex(int v);//给定顶点的位置v，返回对应的顶点值
	int locateVex(Object vex);//给定顶点值vex，返回在图中的位置
	int firstAdjVex(int v);//返回v的第一个邻接点，若没有邻接点，返回-1
	int nextAdjVex(int v, int w);//返回v相对于w的下一个邻接点，若没有，返回-1
}
```

图的类型主要有四种，用枚举类型表示：

```java
public enum GraphKind{
    UDG,//无向图 UnDirected Graph
    DG,//有向图 Directed Graph
    UDN,//无向网 UnDirected Network
    DN;//有向网 Directed Network
}
```

## 2.图的存储结构

### 邻接矩阵

```java
public class MGraph implements IGraph{
    //成员变量
    public final static int INFINITY = Integer.MAX_VALUE;
    private GraphKind kind;     //图的种类
    private int vexnum, arcnum; //顶点数、边数
    private Object[] vexs,      //顶点
    private int[][] arcs,       //邻接矩阵
    //成员方法
    //构造方法
    public MGraph(){
        this(null,0,0,null,null);
    }
    public MGraph(GraphKind kind, int vexnum, int arcnum, Object[] vexs, int[][] arcs){
        this.kind = kind;
        this.vexnum = vexnum;
        this.arcnum = arcnum;
        this.vexs = vexs;
        this.arcs = arcs;
    }
    //其他成员方法
    //创建图
    public void createGraph(){
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入图的类型：");
        GraphKind kind = GraphKind.valueOf(sc.next());//valueOf(String str)方法将字符串转换位枚举类型
        switch(kind) {
            case UDG:
                createUDG();
                return;
            case DG:
                createDG();
                return;
            case UDN:
                createUDN();
                return;
            case DN:
                createDN();
                return;
        }
    }
    //创建无向图
    public void createUDG(){
        ......
    }
    //创建有向图
    public void createDG(){
        ......
    }
    //创建有向网 构造一个具有n个顶点和e条边的网G时间复杂度为O(n^2+en)，其中邻接矩阵的初始化时间复杂度为O(n^2)
    public void createDG(){
        Scanner sc = new Scanner(System.in);
        System.out.println("输入图的顶点数、边数：");
        vexnum = sc.nextInt();
        arcnum = sc.nextInt();
        vexs = new Object[vexnum];//顶点
        System.out.println("请分别输入图的各个顶点：");
        for(int v = 0; v < vexnum; v++) {
            vexs[v] = sc.next();
        }
        arcs = new int[vexnum][vexnum];
        for(int v = 0; v < vexnum; v++) {
            for(int u = 0; u < vexnum; u++) {
                arcs[v][u] = INFINITY;//邻接矩阵
            }
        }
        System.out.println("输入边的两个顶点及权值");
        for(int k = 0; k < arcnum; k++) {
            int v = locateVex(sc.next());
            int u = locateVex(sc.next());
            arcs[v][u] = ac.nextInt();
        }
    }
    //创建无向网
    public void createUDN(){
        Scanner sc = new Scanner(System.in);
        System.out.println("输入图的顶点数、边数：");
        vexnum = sc.nextInt();
        arcnum = sc.nextInt();
        vexs = new Object[vexnum];//顶点
        System.out.println("请分别输入图的各个顶点：");
        for(int v = 0; v < vexnum; v++) {
            vexs[v] = sc.next();
        }
        arcs = new int[vexnum][vexnum];
        for(int v = 0; v < vexnum; v++) {
            for(int u = 0; u < vexnum; u++) {
                arcs[v][u] = INFINITY;//邻接矩阵
            }
        }
        System.out.println("输入边的两个顶点及权值");
        for(int k = 0; k < arcnum; k++) {
            int v = locateVex(sc.next());
            int u = locateVex(sc.next());
            arcs[v][u] = arcs[u][v] = ac.nextInt();
        }
    }
    //返回顶点数
    public int getVexnum(){
        return vexnum;
    }
    //返回边数
    public int getArcnum(){
        return arcnum;
    }
    //给定顶点的值，返回在图中的位置--顶点定位算法
    public int locateVex(Object vex){
        for(int v = 0; v < vexnum; v++) {
            if(vexs[v].equals(vex)) {
                return v;
            }
        }
    }
    //给定顶点的位置v，返回对应的顶点值
    public Object getVex(int v) throws Exception{
        if(v < 0 && v >= vexnum) {
            throw new Exception("第v个顶点不存在")
        }
    }
    //第一个邻接点(*) 时间复杂度O(n)
    public Object firstAdjVex(int v) throw Exception{
        if(v < 0 && v >= vexnum) {
            throw new Exception("邻接点不存在");
        }
        for(int j = 0; j < vexnum; j++) {
            if(arcs[v][j] != 0 && arcs[v][j] < INFINITY) {
                return j;
            }
        }
        return -1;
    }
    //下一个邻接点(*) 时间复杂度O(n)
    public Object nextAdjVex(int v, int w) throw Exception{
        if(v < 0 && v >= vexnum) {
            throw new Exception("邻接点不存在");
        }
        for(int j = w + 1; j < vexnum; j++) {
            if(arcs[v][j] != 0 && arcs[v][j] < INFINITY) {
                return j;
            }
        }
        return -1;
    }
    //其他可能用到的setter和getter
    public GraphKind getKind(){
        return kind;//图种类
    }
    public int[][] getArcs(){
        return arcs;//顶点
    }
    public Object[] getVexs(){
        return vexs;//邻接表
    }
}
```

### 邻接表

